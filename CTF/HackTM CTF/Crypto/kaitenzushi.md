# kaitenzushi

[题目](https://github.com/y011d4/my-ctf-challenges/tree/main/2023-HackTMCTF-2023/crypto/kaitenzushi)

发现了一个很好理解的[wp](https://github.com/Neobeo/HackTM2023/blob/main/crypto_quals.ipynb)，这里记录一下。

```python
from math import gcd
from Crypto.Util.number import bytes_to_long, isPrime

from secret import p, q, x1, y1, x2, y2, e, flag

# properties of secret variables
assert isPrime(p) and p.bit_length() == 768
assert isPrime(q) and q.bit_length() == 768
assert isPrime(e) and e.bit_length() == 256
assert gcd((p - 1) * (q - 1), e) == 1
assert x1.bit_length() <= 768 and x2.bit_length() <= 768
assert y1.bit_length() <= 640 and y2.bit_length() <= 640
assert x1 ** 2 + e * y1 ** 2 == p * q
assert x2 ** 2 + e * y2 ** 2 == p * q

# encrypt flag by RSA, with xor
n = p * q
c = pow(bytes_to_long(flag) ^^ x1 ^^ y1 ^^ x2 ^^ y2, e, n)
print(f"{n = }")
print(f"{c = }")


# hints 🍣
F = RealField(1337)
x = vector(F, [x1, x2])
y = vector(F, [y1, y2])
# rotate
theta = F.random_element(min=-pi, max=pi)
R = matrix(F, [[cos(theta), -sin(theta)], [sin(theta), cos(theta)]])
x = R * x
y = R * y
print(f"{x = }")
print(f"{y = }")
```

rsa，但是密文是经过异或后的flag的加密结果，且e未知。x1，x2，y1，y2组成向量后绕未知角度theta逆时针[旋转](https://zhuanlan.zhihu.com/p/98007510)后输出。脚本里的矩阵R是实数域[RealField](https://doc.sagemath.org/html/en/reference/rings_numerical/sage/rings/real_mpfr.html#sage.rings.real_mpfr.RealField)F上的，其中F的精度达到了1337位。

先尝试找到e。不难，因为最开始的assert已经告诉了我们x1，y1和e的关系，加上旋转不会改变向量的[范数](https://zhuanlan.zhihu.com/p/67120415)（这里可简单理解为向量的长度），因此我们完全可以直接根据获得的x向量和y向量算出e。

```python
F = RealField(1337)
n = 990853953648382437503731888872568785013804329239290721076418541795771569507440261620612308640652961121590348037236708702361580700250705591203587939980126323233833431892076634892318387020242015741789265095380967467201291693288654956012435416445991341222221539511583706970342630678909437274145759598920314784293470918464283814408418704426938549136143925649863711450268227592032494660523680280136089617838412326902639568680941504799777445608524961048789627301462833
c = 312168688094168684887530746663711142224819184527420449851136749248641895825646649162310024737395663075921549510262779965673286770730468773215063305158197748549937395602308558217528064655976647148323981103647078862713773074121667862786737690376212246588956833193632937835958166526006128435536115531865213269197137648990987207140262543956087199861542889002996727146832659889656384027201202873352819689303456895088190857667281342371263570535523695457095802010885279
x = vector([F('9.93659400123277470926327676478883140697376509010297766512845139881487348637477791719517951397052010880811619509960535668814993293095146708957649613776125686226138447162258666762024346093786649228730054881453449071976210130217897905782845690384638460560301964009359233596889465133986468021963885911072779457835979983964294586954038412718305000570678333513135467257498071686562749882446495426493483289204e230'), F('-1.20540611958254673086539287012513674064476659427085664430224592760592531301348857885707154893714440960111029743010026152632150988429192286517249118913535366887447596463819555191858702861383725310592687577510708180057642425944345656558038998574368521689142109798891989865473206201635908814994474491537093810680632691594902962470061189337645818851446622588020765058461348047229165216450857822980873846637e230')])
y = vector([F('9.02899744041999015549480362358897037217795303901085937071039171882835297563545959015336648016772002396355451308252077767567617065937943765701645833054147976124287566465577491039263554806622908070370269238064956822205986576949383035741108310668397305286076364909407660314991847716094610949669608550117248147017329449889127749721988228613503029640191269319151291514601769696635252288607881829734506023770e191'), F('2.82245306887391321716872765000993510002376761684498801971981175059452895101888694909625866715259620501905532121092041448909218372087306882364769769589919830746245167403566884491547911250261820661981772195356239940907493773024918284094309809964348965190219508641693641202225028173892050377939993484981988687903270349415531065381420872722271855270893103191849754016799925873189392548972340802542077635974e192')])
# Step 1: Solve for e
e = int((2*n-x.norm()**2)/y.norm()**2)
f'{e=}'
#'e=111578009802636409437123757591617048189760145423552421418627338749835916561801'
```

接下来是找到旋转前的x和y。思考一下，题目再怎么旋转，弧度都是在0-1内，超过后就绕回来了。如果弧度是0， $x^2+ey^2$ 小于n；如果弧度是1， $x^2+ey^2$ 等于n。只有正确的值保证 $x^2+ey^2=n$ 。基于此，就能使用二分法爆破出原来的x和y。

```python
#Step 2: Solve for x1, x2, y1, y2
def get(theta):
    R = matrix(F, [[cos(theta), -sin(theta)], [sin(theta), cos(theta)]])
    xx = R * x
    yy = R * y
    xx = [int(z + F(1/2)) for z in xx] #这里我发现如果不加F(1/2)，直接转int结果和加上F(1/2)后的结果可能一样，也可能差个很小的值。
    yy = [int(z + F(1/2)) for z in yy] #而且很神奇的一点是，假设xx[0]=1.348382...,int(xx[0])=1348382，不知道为啥变这么大
    t0 = xx[0]**2 + e*yy[0]**2
    t1 = xx[1]**2 + e*yy[1]**2
    return t1, xx, yy

lo, hi = F(0), F(1)
assert get(lo)[0]<n
assert get(hi)[0]>n
for _ in range(2000):
    mid = (lo+hi)/2
    g, xx, yy = get(mid)
    if g == n:
        break
    elif g > n:
        hi = mid
    else:
        lo = mid

x1, x2 = xx
y1, y2 = yy
assert x1**2 + e*y1**2 == n
assert x2**2 + e*y2**2 == n
x1, x2, y1, y2
```

第三步我们还原p和q。还是`assert x1 ** 2 + e * y1 ** 2 == p * q`和`assert x2 ** 2 + e * y2 ** 2 == p * q`这两个条件，我们变形一下。

$x_1^2+ey_1^2=x_2^2+ey_2^2=p\*q$<br>
$e=\frac{-x_1^2}{y_1^2}=\frac{-x_2^2}{y_2^2}=p\*q=n$<br>
$\frac{-x_1^2}{y_1^2}-\frac{-x_2^2}{y_2^2}=n$<br>
$\frac{-x_1^2}{y_1^2}+\frac{x_2^2}{y_2^2}=n$<br>
$(\frac{x_2}{y_2})^2-(\frac{x_1}{y_1})^2=n$<br>
$\left(\frac{x_2}{y_2}+\frac{x_1}{y_1}\right)\left(\frac{x_2}{y_2}-\frac{x_1}{y_1}\right)=n$

（我这里得出来的结果和wp的不一样，可能两者是相等的还是我算错了？）

$\left(\frac{x_2}{y_2}-\frac{x_1}{y_1}\right)\not ={p,q}$ ，所以我们只能尝试用gcd找出p和q。

```python
p = int(gcd(n, x1*y2-x2*y1)) #用我算出来的p = int(gcd(n, x2*y1-x1*y2))也行，或者用另一个式子p = int(gcd(n, x2*y1+x1*y2))也行
q = n // p
assert 1 < p < n and n == p * q

d = pow(e, -1, (p-1)*(q-1))
long_to_bytes(pow(c, d, n) ^ x1 ^ x2 ^ y1 ^ y2)
```

这里的gcd直接交叉相乘，没有除去分母 $y_2y_1$ 。这是因为`x1*y2-x2*y1`肯定比p或者q大，除去 $y_2y_1$ 就不一定了。我们知道p或者q是质数， $y_2y_1$ 是整数，那`x1*y2-x2*y1`与p或者q的gcd一定是p或者q。

## Flag
> HackTM{r07473_pr353rv35_50m37h1n6}