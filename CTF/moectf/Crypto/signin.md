# signin

只要我够会搜，（除了自创题）没有题能难倒我。

搜到这道题答案的关键字是“rsa e和phi不互素”。我只能告诉你这么多了，数学我也不会。如果你也跟我一样努力搜索过，你一定知道大部分搜索出来的内容都提到了AMM算法，这是一种在有限域内开高次方根的算法。不知道为啥，网上搜到的脚本要么没发运行要么要用sagemath。但是我不会用sagemath啊。

我在[这篇](https://tttang.com/archive/1504/)文章里搜到了替代的内容。这其实是搜索引擎跳出来的第一个内容但是提到我能用的解法的内容很少，所以被我忽略了。这道题和NCTF2019的babyRSA很像，但题目提示的一句话让这道题的难度骤降。

- flag < P,Q

这意味着我们在开高次方根后不需要用中国剩余定理了（我猜的，离谱吗？还猜对了）。AMM算法在这道题有一种替代：sympy的nthroot_mod，效果和AMM算法一样。首先安装sympy。

- pip3 install sympy

然后解题脚本就很简单了。

```python
from sympy.ntheory.residue_ntheory import nthroot_mod
from Crypto.Util.number import *
e=65537
p= 12408795636519868275579286477747181009018504169827579387457997229774738126230652970860811085539129972962189443268046963335610845404214331426857155412988073
q= 12190036856294802286447270376342375357864587534233715766210874702670724440751066267168907565322961270655972226761426182258587581206888580394726683112820379
c= 68960610962019321576894097705679955071402844421318149418040507036722717269530195000135979777852568744281930839319120003106023209276898286482202725287026853925179071583797231099755287410760748104635674307266042492611618076506037004587354018148812584502385622631122387857218023049204722123597067641896169655595
n=p*q
print(long_to_bytes(nthroot_mod(c,e,q)))
```

第三个参数填q是因为q-1是e的倍数。你没看错，仅此而已。signin还真挺signin的，如果不把理解原理算在内这道题唯一的难度就是找到脚本:-D。

- ### Flag
  > moectf{Oh~Now_Y0u_Kn0W_HoW_RsA_W0rkS!}