# RSA_revenge

谜底就在谜面上。经过测试，发现`emirp(x)`返回的数字的二进制正好是x的二进制反过来写。意味着我们其实只用知道p或者q的一半bit，剩下的bit将已知bit翻转即可得到。那么函数名emirp是什么东西？询问万能浏览器，正好就是这个特质的英文名： https://en.wikipedia.org/wiki/Emirp 。也是一个在其他比赛考过的内容（可以搜到），见 https://kt.gy/blog/2015/10/asis-2015-finals-rsasr 。稍微改一下脚本的进制和目标bit_length即可
```py
from Crypto.Util.number import *
n = 141326884939079067429645084585831428717383389026212274986490638181168709713585245213459139281395768330637635670530286514361666351728405851224861268366256203851725349214834643460959210675733248662738509224865058748116797242931605149244469367508052164539306170883496415576116236739853057847265650027628600443901
c = 47886145637416465474967586561554275347396273686722042112754589742652411190694422563845157055397690806283389102421131949492150512820301748529122456307491407924640312270962219946993529007414812671985960186335307490596107298906467618684990500775058344576523751336171093010950665199612378376864378029545530793597
base=2
bit_length=512
def t(a, b, k):
    if k == bit_length//2:
        if a*b == n:
            print(long_to_bytes(pow(c,inverse(65537,(a-1)*(b-1)),n)))
        return
    for i in range(2):
        for j in range(2):
            a1 = a + i*(base**k) + j*(base**(bit_length-1-k))
            b1 = b + j*(base**k) + i*(base**(bit_length-1-k))
            if a1*b1 > n:
                continue
            if (a1+(base**(bit_length-1-k)))*(b1+(base**(bit_length-1-k))) < n:
                continue
            if ((a1*b1)%(base**(k+1))) != (n%(base**(k+1))):
                continue
            t(a1, b1, k+1)
t(0,0,0)
```