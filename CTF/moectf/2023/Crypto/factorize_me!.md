# factorize_me!

```py
import random
import math
from Crypto.Util.number import *
from sympy import nextprime
from itertools import product
n=
phi=
def remove_even(n):
    if n == 0:
        return (0, 0)
    r = n
    t = 0
    while (r & 1) == 0:
        t = t + 1
        r = r >> 1
    return (r, t)
def get_root_one(x, k, N):
    (r, t) = remove_even(k)
    oldi = None
    i = pow(x, r, N)
    while i != 1:
        oldi = i
        i = (i*i) % N
    if oldi == N-1:
        return None 
    return oldi
def factor_rsa(phi, N):
    k = phi
    y = None
    while not y:
        x = random.randrange(2, N)
        y = get_root_one(x, k, N)
    p = math.gcd(y-1, N)
    q = N // p
    return (p, q)
p, q = factor_rsa(phi,n)
#print(p, q)
a=6991223361118904775931217829045348785013077549030883418924453538830605687999480005714979700653172534877541317997174968789510984315425270755055110913347281
n=n//a
phi=phi//(a-1)
p, q = factor_rsa(phi,n)
#print(p, q)
b=7592439908930473591169395506464664967460880934907692099467559610659035874008829133810341129161864445676397227262130671224157308868678442281617413952593477
n=n//b
phi=phi//(b-1)
p, q = factor_rsa(phi,n)
#print(p, q)
c=7661276973316857207751367277881032536449069939447322837508906694964933673171693624171780997296797446643574508184011878230465391879808258241752897792891323
n=n//c
phi=phi//(c-1)
p, q = factor_rsa(phi,n)
#print(p,q)
d=6811480804433459752827714558479851837166061762294131563310130325846430072816177165149613687307165209577130630311477665591141650399740741396784593477667511
n=n//d
phi=phi//(d-1)
p, q = factor_rsa(phi,n)
#print(p,q)
e=9987009117206906203158749743824168660291275882852229158070368815160479543708376165641735042845357978292384303332559592302507789120810447986634662721490507
f=11627877395179828773706504422918933052041685770731872812302758181943244472706231518350716590168708806854971155512042158777017234038219076771501368374236727
n=n//(e*f)
phi=phi//((e-1)*(f-1))
p, q = factor_rsa(phi,n)
#print(p,q)
g=10022455487144667211701100343824680124338467215246658405697280466931561838565228778624923751405642974058833143888323468902504576610147119708725877528011439
h=12876877424944854147075816504195994138450356002779004886384584287813869165469217718717854027672044903401715370348223932937626725119320180795716270261309139
i=n//(g*h)
primes=[a,b,c,d,e,f,g,h,i]
next_primes=[]
for p in primes:
    next_primes.append(nextprime(p))
n = 899081756851564072995842371038848265712822308942406479625157544735473115850983700580364485532298999127834142923262920189902691972009898741820291331257478170998867183390650298055916005944577877856728843264502218692432679062445730259562784479410120575777748292393321588239071577384218317338474855507210816917917699500763270490789679076190405915250953860114858086078092945282693720016414837231157788381144668395364877545151382171251673050910143023561541226464220441
e = 65537
c = 841335863342518623856757469220437045493934999201203757845757404101093751603513457430254875658199946020695655428637035628085973393246970440054477600379027466651143466332405520374224855994531411584946074861018245519106776529260649700756908093025092104292223745612991818151040610497258923925952531383407297026038305824754456660932812929344928080812670596607694776017112795053283695891798940700646874515366341575417161087304105309794441077774052357656529143940010140
for comb in product(next_primes, repeat=3):
    p,q,r=comb
    phi=(p-1)*(q-1)*(r-1)
    d=inverse(e,phi)
    if b'moectf' in long_to_bytes(pow(c,d,n)):
        print(long_to_bytes(pow(c,d,n)))
        break
```
与“已知d分解n”相同考点（本身已知e和d分解n就是为了凑phi的倍数，现在有phi直接分解即可）。脚本中的9个素数手动找的(这是个概率算法，每次都`print(p,q)`，当其中一个长得像素数时就拿出来)