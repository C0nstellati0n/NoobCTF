# 0rsa0

还是意思一下吧，我知道我不可能做出来这道题，就参与一下。

```python
from Crypto.Util.number import *
from flag import flag

assert flag[0:7] == b'moectf{'
assert flag[-1:] == b'}'
flag = flag[7:-1]
assert len(flag) == 32

m1 = bytes_to_long(flag[0:16])
m2 = bytes_to_long(flag[16:32])

def enc1(m):
    p = getPrime(512)
    q = getPrime(512)
    n = p * q
    e = 3
    c = pow(m,e,n)
    return n,e,c

def enc2(m):
    p = getPrime(512)
    q = getPrime(512)
    e = 65537
    d = inverse(e,(p-1)*(q-1))
    n = p * q 
    dp2 = d % (p-1)
    c = pow(m,e,n)
    return n,e,c,dp2

n1,e1,c1 = enc1(m1)
n2,e2,c2,dp2 = enc2(m2)

print("n1="+ str(n1))
print("e1="+ str(e1))
print("c1="+ str(c1))
print("n2="+ str(n2))
print("e2="+ str(e2))
print("c2="+ str(c2))
print("dp2="+ str(dp2))
'''
n1=133024413746207623787624696996450696028790885302997888417950218110624599333002677651319135333439059708696691802077223829846594660086912881559705074934655646133379015018208216486164888406398123943796359972475427652972055533125099746441089220943904185289464863994194089394637271086436301059396682856176212902707
e1=3
c1=1402983421957507617092580232325850324755110618998641078304840725502785669308938910491971922889485661674385555242824
n2=159054389158529397912052248500898471690131016887756654738868415880711791524038820158051782236121110394481656324333254185994103242391825337525378467922406901521793714621471618374673206963439266173586955520902823718942484039624752828390110673871132116507696336326760564857012559508160068814801483975094383392729
e2=65537
c2=37819867277367678387219893740454448327093874982803387661058084123080177731002392119369718466140559855145584144511271801362374042596420131167791821955469392938900319510220897100118141494412797730438963434604351102878410868789119825127662728307578251855605147607595591813395984880381435422467527232180612935306
dp2=947639117873589776036311153850942192190143164329999603361788468962756751774397111913170053010412835033030478855001898886178148944512883446156861610917865
'''
```

enc1很简单就解出来了，e过于小，正好是3所以直接开立方就行了（其实我不记得了，也不知道为啥，但是我有脚本！！！）。

enc2就要分析了。前面都是常规操作，除了dp2 = d % (p-1)，这应该就是破解明文唯一的切入点。先设a是 $\frac{d}{(p-1)}$ 的商。

$d=a(p-1)+dp2$ <br>
$d=\frac{d}{(p-1)}*(p-1)+dp2$<br>
$d=d+dp2$

我现在连基本代数都不会了吗？这什么玩意？这个式子根本就不成立。

我不会了。上网搜dp是为了让解密的时候速度更快而产生的，但是现在啥也没有解什么密？而且经典入门题型是给p，q和dp，dq，这就给了一个可以说是非常不新手友好了。

搜到了一条定理。

$dp*e = 1 \mod(p-1)$

我可不知道为啥，我是连初中数论都没学完的废物。

搜到了现成脚本！

```python
import gmpy2
from Crypto.Util.number import *
e=65537
n=159054389158529397912052248500898471690131016887756654738868415880711791524038820158051782236121110394481656324333254185994103242391825337525378467922406901521793714621471618374673206963439266173586955520902823718942484039624752828390110673871132116507696336326760564857012559508160068814801483975094383392729
dp=947639117873589776036311153850942192190143164329999603361788468962756751774397111913170053010412835033030478855001898886178148944512883446156861610917865
c=37819867277367678387219893740454448327093874982803387661058084123080177731002392119369718466140559855145584144511271801362374042596420131167791821955469392938900319510220897100118141494412797730438963434604351102878410868789119825127662728307578251855605147607595591813395984880381435422467527232180612935306
for i in range(1,65538):
    if (dp*e-1)%i == 0:
        if n%(((dp*e-1)//i)+1)==0:
            p=((dp*e-1)//i)+1
            q=n//(((dp*e-1)//i)+1)
            phi = (p-1)*(q-1)
            d = gmpy2.invert(e,phi)%phi
            print(long_to_bytes(pow(c,d,n)))
```

这是脚本小子的绝对胜利！不知道为啥，数论已经学到整除了，等我学成归来必写解释ʕ •ᴥ•ʔ

我回来了，现在比赛早就结束了，刷题时又遇见了相同知识点的题。根据大佬[博客](https://blog.csdn.net/weixin_45369385/article/details/109208109)做个笔记。

首先是rsa提供的已知条件。

$c≡m^e \mod n$<br>
$m\equiv c^d \mod n$<Br>
$\phi(n)=(p-1)\times(q-1)$<br>
$d\times e \equiv 1 \mod\phi (n)$
$dp=d\mod (p-1)$

将dp的式子变形：

$dp=d\mod (p-1)\rightarrow dp\times e\equiv d\times e \mod (p-1)\rightarrow d \times e = k \times (p-1) + dp \times e$

因为ϕ(n)=(p−1)×(q−1)，所以替换式子 $d\times e \equiv 1 \mod\phi (n)$ 得到d×e≡1 mod (p−1)×(q−1)。d和dp同余，所以我们可以把d和dp互换；ϕ(n)=(p−1)×(q−1)，所以加上k个(p−1)后不会改变余数的结果，于是可以得到k×(p−1)+dp×e=1 mod ϕ(n)。继续变形，k×(p−1)+dp×e=1 mod (p−1)×(q−1)。把这个k叫做 $k_1$ ，以便后续区分 $k_2*(p-1)*(q-1)+1$ 。不难看出 $k_1×(p−1)+dp×e=k_2×(p−1)×(q−1)+1$ ，还是因为模的定义。现在就是方程了，做一些简单的代数。

$dp×e= [k_2 ×( p − 1 ) × ( q − 1 ) + 1 ] − [ k_1 × ( p − 1 ) ] =k_2 ×( p − 1 ) × ( q − 1 )- k_1 × ( p − 1 )+1=[k_2*(q-1)-k_1]*(p-1)+1$

设 $X=k_2*(q-1)-k_1$ ,就有

dp\*e=X\*(p-1)+1

 $dp=d\mod (p-1)$ ,所以必定小于p-1。要想满足上面的等式，X必须小小于e， $X\in (0,e)$ ，只要爆破X筛选flag就行了。

## Flag
  > moectf{T8uus_23jkjw_asr_3d32awd!5f&#@sd}