# Weird_E_Revenge

其实这道题很早就搜到了解题方法，但是我因为一个致命低级错误导致怎么都算不出来，还浪费了一个机会去问大佬。啊！！！我为什么不问点更难的题？？？

先感谢这篇[文章](https://www.anquanke.com/post/id/164575)，没有这位大佬我不可能做得出来。让我们按照大佬的思路看一下题。

```python
from Crypto.Util.number import *
import random
from secret import flag
table='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
pad=100-len(flag)
for i in range(pad):
    flag+=random.choice(table).encode()
e=343284449
m=bytes_to_long(flag)
assert m>(1<<512)
assert m<(1<<1024) 
p=getPrime(512)
q=getPrime(512)
r=getPrime(512)
print('p=',p)
print('q=',q)
print('r=',r)
n1=p*q
n2=q*r
c1=pow(m,e,n1)
c2=pow(m,e,n2)
print('c1=',c1)
print('c2=',c2)
#p= 11820891196647569262137841192985418014377132106496147254821784946481523526822939129065042819464351666077658751406165276121125571355594004514547517855730743
#q= 10450390015864176713581330969519712299844487112687677452105216477861582967322473997670559995588440097951786576039009337782247912476227937589298529580432797
#r= 9484954066160968219229920429258150817546418633451929876581842443665029377287119340232501682142185708534413073877473741393278935479791561681402673403009771
#c1= 69574855207460025252857869494766338442370688922127811393280455950372371842144946699073877876005649281006116543528211809466226185922844601714337317797534664683681334132261584497953105754257846471069875622054326463757746293958069752489458646460121725019594141157667480846709081917530190233900184428943585065316
#c2= 66183492015178047844987766781469734325646160179923242098082430373061510938987908656007752256556018402101435698352339429316390909525615464024332856855411414576031970267795270882896721069952171988506477519737923165566896609181813523905810373359029413963666924039857159685161563252396502381297700252749204993228
```

给了p，q和r，看脚本也知道有两组数据。e确实奇怪，先看看能不能直接求模逆元。发现果然不行，e与phi(n1)和phi(n2)的gcd都是e，进一步发现e与q-1的gcd是e。和另一道sighin很像，但是这次e太大了，没法直接有限域开根了。照应题目：奇怪的e带着新值来暴揍我。

不过解法也是很简单的，关键点和上面那篇文章中的题一模一样：将模数转换为能够和e互质的数。先看第一步，由脚本可以得出两个公式。

$x\equiv c1(\mod n1)$<br>
$x\equiv c2(\mod n2)$

这里的x表示什么呢？我们知道两个密文都是由 $m^e$ 模各自的n得到的，所以x就是 $m^e$ 。crt求解就可以得到 $m^e$ 的一个特解。

但是求完还是有问题。e值没有改变，还是那么大，意味着无法爆破或者有限域开根。必须要找到d，但n1和n2都有公因数q，q-1又和e不互质，似乎钻进死胡同了。除非……我们把模数换成p*r。

$result\equiv x=m^e\%p(\mod p)$<br>
$result\equiv x=m^e\%r(\mod r)$

把q去掉，拿刚刚求出的特解再次构造同余方程组。这个同余方程组求出来的特解 $result\equiv m^e (\mod p*r)$ 。可以这么想，设 $a\equiv m^e\%p(\mod p),b\equiv m^e\%r(\mod r)$ ，那么a\*b必定是这个同余方程组的解之一。 $a=k1\times p+m^e,b=k2\times r+m^e$ ，那么 $ab=(k1p+m^e)\times (k2r+m^e)=k1\times k2\times pr+k1pm^e+k2rm^e+m^a,a=2e$ 。 $k1\times k2\times pr+k1pm^e+k2rm^e$ 这段模pr余数肯定是0，但是我不太理解 $m^a$ 这段模pr怎么得到余数是 $m^e$ 的。

推导过程我是跟着大佬做的，大佬使用了三个同余方程组，后面我觉得q用不着就没放进方程组里，最后发现两者都可以求出flag。不知道是只有这道题碰巧了还是所有的都可以。

```python
from sympy.ntheory.modular import crt
from Crypto.Util.number import inverse,long_to_bytes
p= 11820891196647569262137841192985418014377132106496147254821784946481523526822939129065042819464351666077658751406165276121125571355594004514547517855730743
q= 10450390015864176713581330969519712299844487112687677452105216477861582967322473997670559995588440097951786576039009337782247912476227937589298529580432797
r= 9484954066160968219229920429258150817546418633451929876581842443665029377287119340232501682142185708534413073877473741393278935479791561681402673403009771
c1= 69574855207460025252857869494766338442370688922127811393280455950372371842144946699073877876005649281006116543528211809466226185922844601714337317797534664683681334132261584497953105754257846471069875622054326463757746293958069752489458646460121725019594141157667480846709081917530190233900184428943585065316
c2= 66183492015178047844987766781469734325646160179923242098082430373061510938987908656007752256556018402101435698352339429316390909525615464024332856855411414576031970267795270882896721069952171988506477519737923165566896609181813523905810373359029413963666924039857159685161563252396502381297700252749204993228
e=343284449
n1=p*q
n2=q*r
n3=p*r
m=crt([n1,n2],[c1,c2])[0]
m1=m%p
m3=m%r
m=crt([p,r],[m1,m3])[0]
d=inverse(e,(p-1)*(r-1))
print(long_to_bytes(pow(m,d,n3)))
```

那么开头说的低级错误是什么呢？sympy的crt函数中第一个列表是全部的模数，第二个列表是对应的余数。那我搞成什么了呢？我搞反了！导致怎么都求不出答案。我最开始还怪sympy提供的哪门子crt，原来是粗心菜狗没搞清楚。

- ### Flag
  > moectf{Th1s_iS_Chinese_rEm41nDeR_The0rEm_CRT!}