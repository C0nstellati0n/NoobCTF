# 工具脚本

有时候一个知道的知识点却不记得解题脚本放哪个wp里了，又懒得再写一遍。那就专门开个地方存起来。分类就不分了，有些脚本多个分区都能用。

## Base64隐写

[来源](https://zhuanlan.zhihu.com/p/349481870)

```python
import base64

def Base64Stego_Decrypt(LineList):
    Base64Char = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"     #Base64字符集 已按照规范排列
    BinaryText = ""
    for line in LineList:
        if line.find("==") > 0:     #如果文本中有2个=符号
            temp = bin(Base64Char.find(line[-3]) & 15)[2:]      #通过按位与&15运算取出二进制数后4位 [2:]的作用是将0b过滤掉
            BinaryText = BinaryText+"0"*(4-len(temp))+temp      #高位补0
        elif line.find("=") > 0:        #如果文本中有1个=符号
            temp = bin(Base64Char.find(line[-2]) & 3)[2:]       #通过按位与&3运算取出二进制数后2位
            BinaryText = BinaryText+"0"*(2-len(temp))+temp      #高位补0
    Text = ""
    if(len(BinaryText) % 8 != 0):       #最终得到的隐写数据二进制位数不一定都是8的倍数，为了避免数组越界，加上一个判断
        print("警告:二进制文本位数有误，将进行不完整解析。")
        for i in range(0, len(BinaryText), 8):
            if(i+8 > len(BinaryText)):
                Text = Text+"-"+BinaryText[i:]
                return Text
            else:
                Text = Text+chr(int(BinaryText[i:i+8], 2))
    else:
        for i in range(0, len(BinaryText), 8):
            Text = Text+chr(int(BinaryText[i:i+8], 2))      #将得到的二进制数每8位一组对照ASCII码转化字符
        return Text

def Base64_ForString_Decrypt(Text):     #Base64解密
    try:
        DecryptedText = str(Text).encode("utf-8")
        DecryptedText = base64.b64decode(DecryptedText)
        DecryptedText = DecryptedText.decode("utf-8")
    except:
        return 0
    return DecryptedText

if __name__ == "__main__":
    Course = input("文件名:")
    File = open(Course, "r")
    LineList = File.read().splitlines()
    print("显式内容为:")
    for line in LineList:
        print(Base64_ForString_Decrypt(line),end="")
    print("\n隐写内容为:")
    print(Base64Stego_Decrypt(LineList))
```

## Clemency

Clemency是在DEFCON CTF中由LegitBS发明的架构（好家伙出个题直接创造了一个架构）。原生ida不支持此架构，下方链接提供了大佬的插件脚本。

[地址](https://github.com/cseagle/ida_clemency)

## 提取图片内像素

提取图片透明度值异或。

```python
from PIL import Image
img = Image.open('')
m1 = m2 = ''
# 取大图二进制
for y in range(0, img.size[0], 19):
    for x in range(0, img.size[1], 19):
        r,g,b,a = img.getpixel((x,y))
        m1 += str(r & 1)
# 取中间隐写图二进制
for y in range(171, 171 + 19):
    for x in range(171, 171 + 19):
        r,g,b,a = img.getpixel((x,y))
        m2 += str(a & 1)
# 二进制串取异或
xor = ''.join(str(int(A)^int(B)) for A,B in zip(m1,m2))
# 二进制转字符串并输出
print(''.join(chr(int(xor[i:i+8], 2)) for i in range(0, len(xor), 8)))
```

异或两张图片的完整rgb值，并用结果rgb值写另一张图片。

```python
from PIL import Image
image1 = Image.open('n1.png')
image2 = Image.open('n2.png')
print(image1.mode, image2.mode)
size = width, height = image1.size
new = Image.new('RGBA', size)
img1 = image1.load()
img2 = image2.load()
data = new.load()
for x in range(width):
    for y in range(height):
        one = img1[x,y]
        two = img2[x,y]
        new_color = (one[0] ^ two[0],one[1] ^ two[1],one[2] ^ two[2])
        data[x,y]=new_color
new.save("flag.png")
```

图片像素值(rgb)本身就是字节：

```python
from PIL import Image
img = Image.open("ctf.png")
pixels = img.load()
msg = b''
for y in range(img.size[1]):
    for x in range(img.size[0]):
        msg += bytes(pixels[x, y])
print(msg.decode())
```

## 词频统计

统计单词出现的次数就比较麻烦，需要自己构建字典。比如这道题：[浪里淘沙](https://www.cnblogs.com/Konmu/p/12527029.html)。

```python
f=open("ctf.txt",'r')
data=f.read()
f.close()
statistics={}
frequency=[]
num=[4,8,11,15,16]
def zipin(lsit):
    for i in lsit:
        statistics.setdefault(data.count(i),str(i))
        frequency.append(data.count(i))
    frequency.sort()
    for i in num:
        print(''.join(statistics.get(frequency[i-1])),end='')
    print('\n')
    return(statistics)

letters=[]
print(zipin(letters))
```

## xxtea

解密与加密脚本的python实现。[来源](https://www.cnblogs.com/DirWang/p/12198526.html)。

```python
import struct

_DELTA = 0x9E3779B9


def _long2str(v, w):
    n = (len(v) - 1) << 2
    if w:
        m = v[-1]
        if (m < n - 3) or (m > n): return ''
        n = m
    s = struct.pack('<%iL' % len(v), *v)
    return s[0:n] if w else s


def _str2long(s, w):
    n = len(s)
    m = (4 - (n & 3) & 3) + n
    s = s.ljust(m, b"\0")
    v = list(struct.unpack('<%iL' % (m >> 2), s))
    if w: v.append(n)
    return v


def encrypt(str, key):
    if str == '': return str
    v = _str2long(str, True)
    k = _str2long(key.ljust(16, b"\0"), False)
    n = len(v) - 1
    z = v[n]
    y = v[0]
    sum = 0
    q = 6 + 52 // (n + 1)
    while q > 0:
        sum = (sum + _DELTA) & 0xffffffff
        e = sum >> 2 & 3
        for p in  range(n):
            y = v[p + 1]
            v[p] = (v[p] + ((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z))) & 0xffffffff
            z = v[p]
        y = v[0]
        v[n] = (v[n] + ((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4) ^ (sum ^ y) + (k[n & 3 ^ e] ^ z))) & 0xffffffff
        z = v[n]
        q -= 1
    return _long2str(v, False)


def decrypt(str, key):
    if str == '': return str
    v = _str2long(str, False)
    k = _str2long(key.ljust(16, b"\0"), False)
    n = len(v) - 1
    z = v[n]
    y = v[0]
    q = 6 + 52 // (n + 1)
    sum = (q * _DELTA) & 0xffffffff
    while (sum != 0):
        e = sum >> 2 & 3
        for p in range(n, 0, -1):
            z = v[p - 1]
            v[p] = (v[p] - ((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z))) & 0xffffffff
            y = v[p]
        z = v[n]
        v[0] = (v[0] - ((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4) ^ (sum ^ y) + (k[0 & 3 ^ e] ^ z))) & 0xffffffff
        y = v[0]
        sum = (sum - _DELTA) & 0xffffffff
    return _long2str(v, True)
```

## openssl解密

### RSA

- openssl rsautl -decrypt -inkey privatekey.key -in cipher.enc -out result

### AES

- openssl enc -d -aes-128-cbc -md md5 -pass pass:SevenPinLock0123456 -in flag.aes128cbc
- openssl enc -aes-256-cbc -d -in flag.enc -out res -salt -iv xxx -K xxx

### CSR文件

- openssl req -in file.csr -noout -text

## openssl私钥格式

头和尾分别需要包含这两行：

```
-----BEGIN RSA PRIVATE KEY-----
-----END RSA PRIVATE KEY-----
```

## 批量openssl解密并合并图片

例题：[Mysterious-GIF](https://github.com/C0nstellati0n/NoobCTF/blob/main/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/6%E7%BA%A7/Misc/Mysterious-GIF.md)

## uncompyle6反编译pyc

- uncompyle6 -o result.py ctf.pyc
- uncompyle6的一个fork，可处理一些uncompyle6无法反编译的高版本pyc： https://github.com/rocky/python-decompile3

## 读取两个文件内容并xor

要求两个文件内容长度一致。

```python
from Crypto.Util.strxor import strxor
with open("a.txt") as f:
    data1=f.read()
with open("b.txt") as f:
    data2=f.read()
print(strxor(data1.encode(),data2.encode()))
```

## 简单z3使用

z3默认只会给出一个解，如果想要全部的解可以像下面这样：

```python
#https://stackoverflow.com/questions/13395391/z3-finding-all-satisfying-models
while s.check() == z3.sat:  
    solution = "False"
    m = s.model()
    for i in m:
        solution = f"Or(({i} != {m[i]}), {solution})"
    f2 = eval(solution)
    s.add(f2)
```

例题1:[EquationPy](https://github.com/C0nstellati0n/NoobCTF/blob/main/CTF/moectf/Reverse/EquationPy.md)。例题2(z3的BitVec的使用,可使用异或位移等操作):[ezhash](https://github.com/C0nstellati0n/NoobCTF/blob/main/CTF/moectf/Crypto/ezhash.md)

再给出一个求解flag的模板脚本。

```python
from z3 import *

s = []
s_length=25
for i in range(s_length):
    #有的时候BitVec不行可以换Int，说不定能出来。前提是没有BitVec独有的操作
    byte = BitVec("%s" % i, 8)
    s.append(byte)

z = Solver()

#这里写约束

flag_format = "flag{"

for i in range(len(flag_format)):
    z.add(s[i] == ord(flag_format[i]))

# check if all chars would be ascii printable
for i in range(len(flag_format),s_length):
     z.add(s[i] >= ord('!'))
     z.add(s[i] <= ord('~'))
     
# chack if the last char would be "}"
z.add(s[-1] == ord('}'))

# check if z3 can solve it
if z.check() == sat:
    solution = z.model()
    flag = ""
    for i in range(0, s_length):
        flag += chr(int(str(solution[s[i]])))
    print(flag)

#Check if z3 can't solve it
elif z.check() == unsat:
    print("Failed:" + str(z.check()))
```
- https://meashiri.github.io/ctf-writeups/posts/202307-cryptoctf/#blue-office ：Extract函数使用. `Extract(high, low, expr)`:
    - high is the index of the highest bit to extract.
    - low is the index of the lowest bit to extract.
    - expr is the expression from which the bits are to be extracted.

## python3实现换表base64解密

此脚本为题目[easyjni](https://adworld.xctf.org.cn/challenges/details?hash=ebe1d9bb-662e-4922-a257-828d58e2a4aa_2&task_category_id=6)的解题脚本。

```python
from base64 import b64decode
data=list('MbT3sQgX039i3g==AQOoMQFPskB1Bsc7')
index=0
for i in range(0,len(data),2):
	data[i],data[i+1]=data[i+1],data[i]
flag=''.join(data[16:]+data[:16])
STANDARD_ALPHABET = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
CUSTOM_ALPHABET = b'i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN'
DECODE_TRANS = bytes.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)
print(b64decode(flag.translate(DECODE_TRANS)))
```

换表后题目给出的字符不全就要用itertools爆破，比如：

```python
from base64 import b64decode
import itertools
cipher=b'MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD=='
STANDARD_ALPHABET = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for i in itertools.permutations(b"ju34",4):
    s=''.join([chr(j) for j in i])
    CUSTOM_ALPHABET = b'JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs'+s.encode()+b'kxyz012789+/'
    DECODE_TRANS = bytes.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)
    print(b64decode(cipher.translate(DECODE_TRANS)))
```

例题：[[WUSTCTF2020]B@se](https://buuoj.cn/challenges#[WUSTCTF2020]B@se)

## python爆破sha1值

[来源](https://blog.csdn.net/qq_42967398/article/details/96492843)

```python
import hashlib

flag = "@DBApp"

for i in range(100000,999999):
	s = str(i)+flag
	x = hashlib.sha1(s.encode())
	cnt = x.hexdigest()
	if "6e32d0943418c2c" in cnt:
		print(cnt)
		print(str(i)+flag)
```

## 常见文件文件头、文件尾

[链接](https://en.wikipedia.org/wiki/List_of_file_signatures)

补充：

- RAR文件尾：C4 3D 7B 00 40 07 00
- jpg文件尾：FF D9
- encrypto加密软件加密文件的文件头：4D 50 45 31(MPE1)，后缀.crypto
- [pyAesCrypt](https://github.com/marcobellaccini/pyAesCrypt)模块密文文件：41 45 53 02。提供一个解密脚本。

```python
import pyAesCrypt
buffersize=0
password=''
pyAesCrypt.decryptFile("cipher.enc","plain",password,buffersize)
```
- png文件尾:AE 42 60 82

## C语言格式化字符串参考

[链接](https://blog.csdn.net/chenmozhe22/article/details/109738852)

## serpent分组加密算法

详情见大佬[博客](https://blog.csdn.net/douqingl/article/details/50256931)。可使用[在线网站](https://www.tools4noobs.com/online_tools/decrypt/)直接解密。

## exif查看

misc或者osint题型中，可能会有信息藏在exif头中。使用[在线工具](https://exif.tools/upload.php)查看。

## dijkstra最短路径寻路算法

例题：[救世捷径](https://buuoj.cn/challenges#%E6%95%91%E4%B8%96%E6%8D%B7%E5%BE%84)

```python
#dijkstra算法
graph=[]
for i in range(27):
    graph.append([])
for i in range(27):
    for j in range(27):
        graph[i].append(0x3f3f3f)
f=open('dj.txt','r').readlines()#这里需要手动将原文中的最后一行换行给去掉
li=[]
for x in f:
    li.append(x.strip().split(' '))
#print(li)
#print(graph)
for x in li:
    graph[int(x[0])][int(x[1])]=int(x[2])
    graph[int(x[1])][int(x[0])]=int(x[2])
#print(graph)
def dijkstra():
    dv=[0x3f3f3f for i in range(27)]#点i到起点1的最短距离
    route=[1 for i in range(27)]#记录每点和与它对应的上一点
    vis=[0 for i in range(27)]#各点到起点的最短距离是否已定.
    for i in range(2,27):
        dv[i]=graph[i][1]
    dv[1]=0
    #print(dv)
    vis[1]=1
    for i in range(26):
        minn=0x3f3f3f
        temp=-1
        for j in range(2,27):
            if vis[j]==0 and minn>dv[j]:
                minn=dv[j]
                temp=j
        vis[temp]=1
        #print(temp)
        for j in range(2,27):
            if dv[j]>dv[temp]+graph[temp][j]:
                dv[j]=dv[temp]+graph[temp][j]
                route[j]=temp
    return (route,dv)
route,dv=dijkstra()
print(dv[26])
print(route)
y=26
while y!=1:
    print(y)#这里输出路径
    y=route[y]
```

## 多重base编码解密脚本

有时候会遇到base编码疯狂套娃，手动放工具里都要点击解密很多次，不如直接脚本自动化。

```python
import base64
with open (r'flag_encode.txt','r',encoding='utf-8') as f:
    for a in f:
        while 1:
            try :
                a=base64.b64decode(a).decode("utf-8")
            except:
                pass
            try:
                a=base64.b32decode(a).decode("utf-8")
            except:
                pass
            try:
                a=base64.b16decode(a).decode('utf-8')
            except:
                pass
            if "{" in a:
                print (a)
                break
```

## 字频统计脚本

[来源](https://blog.csdn.net/mochu7777777/article/details/109377328)

```python
alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()_+- =\\{\\}[]"
strings = open('flag.txt').read()

result = {}
for i in alphabet:
	counts = strings.count(i)
	i = '{0}'.format(i)
	result[i] = counts

res = sorted(result.items(),key=lambda item:item[1],reverse=True)
for data in res:
	print(data)

for i in res:
	flag = str(i[0])
	print(flag[0],end="")
```

## 二叉树遍历

### 根据中序+后序遍历结果获取先序遍历结果

```python
def ToPreOrder(Postorder,Inorder):
    length = len(Postorder)
    if length == 0:
        return 0
    root = Postorder[length-1] #根节点　
    for i in range(length):#找到中序遍历中根节点的位序
        if root == Inorder[i]:
            break
    print(root,end="")
    ToPreOrder(Postorder[0:i],Inorder[0:i]) #递归，传入左子树的后序和中序遍历序列
    ToPreOrder(Postorder[i:length-1],Inorder[i+1:length])#递归，传入右子树的后序和中序遍历序列
```

### 根据前序+中序遍历结果获取后序遍历结果

[例题及来源](https://blog.csdn.net/ao52426055/article/details/110420027)

```python
def get_after_deep(pre, mid, a):#已知前中，求后，a就是后序
    if len(pre) == 1:
        a.append(pre[0])
        return
    if len(pre) == 0:
        return
    root = pre[0]
    root_index = mid.index(root)
    get_after_deep(pre[1:root_index+1], mid[:root_index], a)
    get_after_deep(pre[root_index+1:], mid[root_index+1:], a)
    a.append(root)
    return a


def get_hou():
    pre=input("请依次输入前序遍历、中序遍历的结果，以换行分割:\n")
    mid=input()
    pre_list=list(pre)
    mid_list=list(mid)
    a=[]
    res_list=get_after_deep(pre,mid,a)
    res="".join(res_list)
    print("后序遍历为:",res)
get_hou()
```

例题:[[WUSTCTF2020]level4](https://github.com/C0nstellati0n/NoobCTF/blob/main/CTF/BUUCTF/Reverse/%5BWUSTCTF2020%5Dlevel4.md)

## python时间戳相关+获取文件访问/创建/修改时间

[来源](https://www.cnblogs.com/shaosks/p/5614630.html)

```python
import os
import time
from datetime import datetime
'''把时间戳转化为时间: 1479264792 to 2016-11-16 10:53:12'''
def TimeStampToTime(timestamp):
	timeStruct = time.localtime(timestamp)
	return time.strftime('%Y-%m-%d %H:%M:%S',timeStruct)
def time_to_time_stamp(str_time):
    dt = datetime.strptime(str_time, '%Y-%m-%d %H:%M')
    return dt.timestamp()
'''获取文件的大小,结果保留两位小数，单位为MB'''
def get_FileSize(filePath):
	fsize = os.path.getsize(filePath)
	fsize = fsize/float(1024*1024)
	return round(fsize,2)
'''获取文件的访问时间'''
def get_FileAccessTime(filePath):
	t = os.path.getatime(filePath)
	print(f"时间戳:{t}\n时间:{TimeStampToTime(t)}")
'''获取文件的创建时间'''
def get_FileCreateTime(filePath):
	t = os.path.getctime(filePath)
	print(f"时间戳:{t}\n时间:{TimeStampToTime(t)}")
'''获取文件的修改时间'''
def get_FileModifyTime(filePath):
	t = os.path.getmtime(filePath)
	print(f"时间戳:{t}\n时间:{TimeStampToTime(t)}")
```

## 嵌套zip文件解压

### 根据名称

[来源](https://blog.csdn.net/mochu7777777/article/details/109585465)和[zipfile参考](https://docs.python.org/zh-cn/3/library/zipfile.html)。

```python
import zipfile
name = '0573'
while True:
    fz = zipfile.ZipFile(name + '.zip', 'r')
    fz.extractall(pwd=bytes(name, 'utf-8'))
    name = fz.filelist[0].filename[0:4]
    fz.close()
```
### 根据后缀并解压至当前目录

```sh
# https://unix.stackexchange.com/questions/4367/extracting-nested-zip-files
# https://askubuntu.com/questions/146634/shell-script-to-move-all-files-from-subfolders-to-parent-folder
while [ "`find . -type f -name '*.zip' | wc -l`" > 0 ]
do
    unzip *.zip
    rm *.zip
    find . -mindepth 2 -type f -print -exec mv {} . \;
    rmdir */
done
```

## python根据RGB数据生成图片

[来源](https://blog.csdn.net/mochu7777777/article/details/109585465)及[PIL参考](https://blog.csdn.net/weixin_43790276/article/details/108478270)

```python
from PIL import Image

x = y = 200
img = Image.new("RGB",(x,y))
file = open('./qr.txt','r')

for width in range(0,x):
    for height in range(0,y):
        line = file.readline()
        rgb = line.split(',')
        img.putpixel((width,height),(int(rgb[0]),int(rgb[1]),int(rgb[2])))
img.save('flag.jpg')
```

## 多重base64|16|32|85混合套娃解密脚本

[来源](https://blog.csdn.net/mochu7777777/article/details/109829704)

```python
#!/usr/bin/env python

import base64
import re

def baseDec(text,type):
    if type == 1:
        return base64.b16decode(text)
    elif type == 2:
        return base64.b32decode(text)
    elif type == 3:
        return base64.b64decode(text)
    elif type == 4:
        return base64.b85decode(text)
    else:
        pass

def detect(text):
    try:
        if re.match("^[0-9A-F=]+$",text.decode()) is not None:
            return 1
    except:
        pass
    
    try:
        if re.match("^[A-Z2-7=]+$",text.decode()) is not None:
            return 2
    except:
        pass

    try:
        if re.match("^[A-Za-z0-9+/=]+$",text.decode()) is not None:
            return 3
    except:
        pass
    
    return 4

def autoDec(text):
    while True:
        if b"MRCTF{" in text:
            print("\n"+text.decode())
            break

        code = detect(text)
        text = baseDec(text,code)

with open("flag.txt",'rb') as f:
    flag = f.read()

autoDec(flag)
```

## 汇编指令与机器码对照表

[链接](https://www.jianshu.com/p/7835b5526854)

## python运算符优先级

[链接](http://c.biancheng.net/view/2190.html)

## python以大端和小端处理数据

[题目及来源](https://blog.csdn.net/MikeCoke/article/details/113796480)

```python
from Crypto.Util.number import *
import struct

s = [72143238992041641000000.000000,77135357178006504000000000000000.000000,1125868345616435400000000.000000,67378029765916820000000.000000,75553486092184703000000000000.000000,4397611913739958700000.000000,76209378028621039000000000000000.000000]
a = ''
b = ''
for i in s:
    i = float(i)
    a += struct.pack('<f',i).hex()        #小端
print(a)

for j in s:
    i = float(i)
    b += struct.pack('>f',i).hex()        #大端
print(b)

a = 0x496e74657265737472696e67204964656120746f20656e6372797074
b = 0x74707972747079727470797274707972747079727470797274707972
print(long_to_bytes(a))
print(long_to_bytes(b))
```

## RC4加密脚本

[题目及来源](https://blog.csdn.net/mochu7777777/article/details/105661450)。RC4加密和解密都是一个方法。

```python
import base64
from urllib import parse

def rc4_main(key = "init_key", message = "init_message"): #返回加密后的内容
    s_box = rc4_init_sbox(key)
    crypt = str(rc4_excrypt(message, s_box))
    return  crypt

def rc4_init_sbox(key):
    s_box = list(range(256)) 
    j = 0
    for i in range(256):
        j = (j + s_box[i] + ord(key[i % len(key)])) % 256
        s_box[i], s_box[j] = s_box[j], s_box[i]
    return s_box
def rc4_excrypt(plain, box):
    res = []
    i = j = 0
    for s in plain:
        i = (i + 1) % 256
        j = (j + box[i]) % 256
        box[i], box[j] = box[j], box[i]
        t = (box[i] + box[j]) % 256
        k = box[t]
        res.append(chr(ord(s) ^ k))
    cipher = "".join(res)
    return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))

key = "HereIsTreasure"  #此处为密钥
message = input("请输入明文:\n")
enc_base64 = rc4_main( key , message )
enc_init = str(base64.b64decode(enc_base64),'utf-8')
enc_url = parse.quote(enc_init)
print("rc4加密后的url编码:"+enc_url)
#print("rc4加密后的base64编码"+enc_base64)
```

## SSH连接远程服务器

假设用户名是root，服务器为node4.buuoj.cn，端口25298，则这样连接：

- ssh -p 25298 root@node4.buuoj.cn
  
更多ssh参考[此处](https://blog.csdn.net/li528405176/article/details/82810342)。

## python Crypto解密des密文

[题目及来源](https://www.anquanke.com/post/id/181019#h3-15)

```python
import base64
from Crypto.Cipher import DES
key = b"t\x00e\x00s\x00t\x00"
des = DES.new(key, mode = DES.MODE_CBC, iv = key)
a = b"xZWDZaKEhWNMCbiGYPBIlY3+arozO9zonwrYLiVL4njSez2RYM2WwsGnsnjCDnHs7N43aFvNE54noSadP9F8eEpvTs5QPG+KL0TDE/40nbU="
a = base64.b64decode(a)
res = des.decrypt(a)[0:-6].decode("utf-16")
print(res)
```

## 常见算法特征总结

[链接](https://b0ldfrev.gitbook.io/note/miscellaneous/suan-fa-te-zheng-zong-jie)

## GCC编译C文件为可执行文件

- gcc source.c -o result.o

## 套娃压缩文件解压bash脚本

[例题及来源](https://blog.csdn.net/mochu7777777/article/details/110051084)

```bash
while [ "`find . -type f -name '*.tar.xz' | wc -l`" -gt 0 ]; do find -type f -name "*.tar.xz" -exec tar xf '{}' \; -exec rm -- '{}' \;; done;
```

## Nim博弈pwntools交互

[来源](https://xia0ji233.pro/2023/01/01/Nepnep-CatCTF2022/#catnim)。有关nim博弈可以参考[此处](https://zhuanlan.zhihu.com/p/422562139)。

```python
from pwn import *
#context.log_level='debug'
def get_pile():
    p.recvuntil('Now pile: ')
    line=p.recvline()[:-1].decode()
    return line.split(' ')
def get_xor(piles):
    v=0
    for num in piles:
        v^=num
    print("xor :",v)
    return v
def choose(piles):
    v=get_xor(piles)
    i=0
    for num in piles:
        if num-(num^v) > 0:
            return i,num-(num^v)
        i+=1
    return None,None
p=remote('223.112.5.156',55068)
p.sendline('N')
start=time.time()
while True:
    piles=get_pile()
    pilesnum=[int(i) for i in piles]
    where,cnt=choose(pilesnum)
    print(pilesnum)
    s=0
    for num in pilesnum:
        if num==0:
            s+=1
    p.sendlineafter('where:',str(where))
    p.sendlineafter('count:',str(cnt))
    if s==len(pilesnum)-1:
        break
    piles=get_pile()
print(time.time()-start)
p.interactive()
#print(pilesnum)
p.interactive()
```

## 路径编程问题

从m点到 n 点走 k 步的[路径条数问题](https://blog.csdn.net/bbbbswbq/article/details/81177945)。[题目及来源](https://blog.csdn.net/qq_41956187/article/details/105731368)

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
const int N = 105;
const int mod = 10003;
struct node
{
    int a[N][N];
};
node c, ans;
int n;
node mul(node x, node y)
{
    node ans;
    memset(ans.a, 0, sizeof(ans.a));
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            if (x.a[i][k])
                for (int j = 1; j <= n; j++)
                {
                    ans.a[i][j] += x.a[i][k] * y.a[k][j];
                    ans.a[i][j] %= mod;
                }
        }
    }
    return ans;
}
node Pow(node x, int m)
{
    node ans;
    memset(ans.a, 0, sizeof(ans.a));
    for (int i = 1; i <= n; i++)
        ans.a[i][i] = 1;
    while (m)
    {
        if (m & 1)
            ans = mul(ans, x);
        x = mul(x, x);
        m >>= 1;
    }
    return ans;
}
int main()
{
    freopen("yyh.in","r",stdin);
    freopen("out","w",stdout);
    int m, u, v, step;
    scanf("%d %d %d", &n, &m, &step);
    memset(c.a, 0, sizeof(c.a));
    while (m--){
        scanf("%d %d", &u, &v);
        c.a[u][v] = c.a[v][u] = 1;
    }

    ans = Pow(c, step);
    printf("%d\n", ans.a[1][n]);
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```

## python pickle opcodes参考

[来源](https://www.leavesongs.com/PENETRATION/code-breaking-2018-python-sandbox.html)。例题:[[SUCTF 2019]Guess Game](https://zhuanlan.zhihu.com/p/90798308)

```
c：引入模块和对象，模块名和对象名以换行符分割
}：push一个空的字典，相当于push {}
S: push一个字符串
I: push一个整型
s: pop两位 ，然后作为字典的key和value
b: 调用__setstate__ 或者 __dict__.update()
(：压入一个标志到栈中，表示元组的开始位置
t：从栈顶开始，找到最上面的一个(，并将(到t中间的内容全部弹出，组成一个元组，再把这个元组压入栈中
R：从栈顶弹出一个可执行对象和一个元组，元组作为函数的参数列表执行，并将返回值压入栈上
p：将栈顶的元素存储到memo中，p后面跟一个数字，就是表示这个元素在memo中的索引
V、S：向栈顶压入一个（unicode）字符串
.：表示整个程序结束
```

## python bfs寻最长路径实现

[原题](https://github.com/ev0A/SCTF2019-Write-Up#maaaaaaze)的路径在html的td标签中，所以还需要BeautifulSoup处理一下html

```python
#处理html部分
from bs4 import BeautifulSoup
from collections import deque
import re

with open("Maze.html", "r") as file:
    html_doc = file.read()
soup = BeautifulSoup(html_doc, 'html.parser')
lattice = soup.find_all('td')
pattern = re.compile(r'border-([a-z]+):')
maze = []
for j in range(100):
    temp1 = []
    for i in range(j * 100, j * 100 + 100):
        temp = ""
        result = pattern.findall(str(lattice[i]))
        print(result)
        if 'top' not in result:
            temp += "u"
        if 'bottom' not in result:
            temp += "d"
        if 'right' not in result:
            temp += "r"
        if 'left' not in result:
            temp += "l"
        temp1.append(temp)
    maze.append(temp1)
#bfs部分，参考Nu1l师傅的脚本，更加简洁
move = {'u': (-1, 0), 'd': (1, 0), 'l': (0, -1), 'r': (0, 1)}
queue = deque()
queue.append(((0, 0), 0))
visited = []
ans = 0
ansv = ()
while queue:
    v, res = queue.popleft()
    if res > ans:
        ans = res
        ansv = v
    if v not in visited:
        visited.append(v)
        for adj in maze[v[0]][v[1]]:
            queue.append(((v[0] + move[adj][0], v[1] + move[adj][1]), res + 1))
print(ansv, ans)
```

## PIL遍历图片的rgb值并打印

[来源](https://xelessaway.medium.com/0xl4ugh-ctf-2023-c86b0421fd23)

```python
import numpy as np
from PIL import Image
import random
img = Image.open('Chall.png')
pix = img.load()
w, h = img.size
for i in range(w):
    for c in range(h):
        r,g,b,a = img.getpixel((i,c))
        if r == 255 and g == 255 and b == 255:
            pass
        else:
            print(r,g,b,a)
```

## PIL+numpy+cv2处理带有图片像素值的txt

[来源](https://xelessaway.medium.com/0xl4ugh-ctf-2023-c86b0421fd23)

```python
import numpy as np
from PIL import Image as im
import cv2
with open('weirdoooo.txt', 'r') as f:
    data = f.read().split('\n')
data2 = []
# create empty img 1024*1024
img = np.zeros((1024,1024))
for i in range(len(data)):
    data2.append(data[i].split(' '))
for i in range(len(data2)):
    for j in range(len(data2[i])):
        if  data2[i][j] == '':
            pass
        else:
            img[i][j]=data2[i][j]
print(img.shape)
out=img.astype(np.uint8) #数值类型转换， https://numpy.org/doc/stable/reference/generated/numpy.ndarray.astype.html
out = im.fromarray(out) #从数组转为图片， https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.fromarray
#out.convert()
out.save('flag.png')
flag = cv2.imread('flag.png') #opencv的参考https://www.geeksforgeeks.org/python-opencv-cv2-imread-method/
cv2.imshow('flag',flag)
cv2.waitKey(0)
```

## 使用pefile库读取pefile文件内容并修改

[来源](https://gist.github.com/matthw/4ce2a4b9e76eb7008d55661e4792f463)。这道题的题目文件加密了重要的检查逻辑文件，且不是直接写的pe文件，还往里面加了没用的数据。直接用pefile读取有效的数据改回来就行了。

```python
import pefile

pe = pefile.PE("evil.exe")
key = b'PHALAN'

def get_resource(pe):
    for rsrc_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
        for rsrc in rsrc_type.directory.entries:
            rsrc = rsrc.directory.entries[0].data.struct
            return pe.get_data(rsrc.OffsetToData, rsrc.Size)

def decrypt(data, key):
    out = bytearray(len(data))
    for n, b in enumerate(data):
        if data[n] == 0:
            continue
        if data[n] == key[n % len(key)]:
            out[n] = data[n]
            continue
        out[n] = data[n] ^ key[n % len(key)]
    return out

data = get_resource(pe)

yo = decrypt(data, key)

with open("dumped.pe", "wb") as fp:
    fp.write(yo)
```

## python解决最大权重配对问题（maximum weight matching）

[例题及来源](https://enscribe.dev/ctfs/mhs/prog/matchmaker/)，涉及到基本的图论（graph theory）和开花算法（The Blossom Algorithm）。

```python
from pwn import remote
import networkx as nx
import networkx.algorithms.matching as matching

def parse_input(data: str) -> list[list[int]]:
    data = [list(map(int, x.split())) for x in data.splitlines()[:-1]]
    [data[i].insert(i, 0) for i in range(len(data))]
    return data

def main() -> None:
    p = remote('0.cloud.chals.io', [PORT])
    for _ in range(3):
        data = [[0, 0, 100, 0], [0, 100, 0, 0], [0, 100, 0, 0], [100, 0, 0, 0]]
        data = parse_input(p.recvuntilS(b'> '))
        G: nx.Graph = nx.Graph([(i, j, {'weight': data[i][j] + data[j][i]}) for i in range(len(data)) for j in range(len(data[i])) if i != j])
        M: set[tuple] = matching.max_weight_matching(G, maxcardinality=True)
        M_S: list[tuple] = sorted(list(M) + [(b, a) for a, b in M])
        result: str = ';'.join([f'{a},{b}' for a, b in M_S])
        print(data)
        p.sendline(result.encode())

    p.interactive()

if __name__ == '__main__':
    main()
```

## [gdb使用](https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf)([pwndbg](https://www.cnblogs.com/murkuo/p/15965270.html)）

补充：

- stack \<num\>
  > 指定查看多少栈内容，直接stack查看的栈帧是不完整的)
- starti <参数>
  > 无论程序去除符号与否，该命令都能保证在程序的开始断下。可以传入参数。
- info file
  > 查看文件信息，可用于获取文件加载基址
- x/i $pc
  > 查看当前地址的字节码的反汇编结果
- layout asm
  > 打开反汇编窗口
- [tbreak](https://www.irya.unam.mx/computo/sites/manuales/fce12/debugger/cl/commandref/gdb_mode/cmd_tbreak.htm)
  > 在指定位置插入临时断点
- info proc mappings
  > 查看所有映射，可获取libc加载基址
- x/10g $sp
  > 数字10可以任意更改，表示要查看栈上多少个元素。
- p $ebp-0x4
  > 打印对应地址的内容，可配合寄存器使用
- find start,end,str
  > 在start-end的内存中寻找str的地址
- disas [函数名/地址]
  > 反编译置顶位置的指令。如果当前所处位置就是想要反编译的函数，可以直接disas。
- [内存断点](https://stackoverflow.com/questions/58851/can-i-set-a-breakpoint-on-memory-access-in-gdb)：
  - watch *addr
    > gdb will break when a write occurs
  - rwatch *addr
    > gdb will break wnen a read occurs
  - awatch *addr
    > gdb will break in both cases
- set $rip = value (set $eip = value)
  - 设置当前程序的rip/eip（64/32）
- jump _start
  > 重启程序
- find_fake_fast addr size
  > 在指定addr处寻找size大小的符合fastbin的假堆块（找到可用错位获取合法size的地址）
- info threads
  > 查看存在的线程
- `thread <thread_id>`
  > 切换到指定id的线程
- `set *(char **)addr = value`
    > 设置addr处的内存（64bit），参考 https://stackoverflow.com/questions/35370698/how-to-set-an-arbitrary-64-bits-of-memory-in-gdb
    - 同理还可以修改汇编指令，找到指令所在的地址处即可。`set *(unsigned char*)addr=byte`(https://stackoverflow.com/questions/6473908/can-gdb-change-the-assembly-code-of-a-running-program).不过这样改是暂时的，重新run的话就要再patch一次
- `gdb -batch -ex 'file <program>' -ex 'disassemble <func_name>'`
    - 反汇编某个程序的某个函数，参考 https://stackoverflow.com/questions/22769246/how-to-disassemble-one-single-function-using-objdump
- `jump <addr>`
    - 跳转到某个地址
- 一些pwndbg独有的[命令](https://browserpwndbg.readthedocs.io/en/docs/)
- `distance a b`
 > 获取从a到b地址的差值
- `vis_heap_chunks`
    > 查看堆块（不同堆块会用不同颜色区分）
- `brva offset`
    - 在当前程序的基地址+offset处下断点。要求程序已运行（比如先starti再brva）

## docker命令

- docker run --platform linux/amd64 -it ubuntu /bin/bash
  > 开启amd64位的ubuntu container，如果本地没有相应镜像就会自动拉取并开启。注意已有container后无需使用该命令再次创建一个container。
- docker container start [container name]
  > 运行一个已创建的container
- docker container ls
  > 查看已有的container
- docker container attach [CONTAINER ID]
  > 附加到一个已运行的container（可获取高亮，自动补全，需要先用`docker container start`启动container）
- docker rename [old name] [new name]
  > 重命名container
- docker run -i -v "\`pwd\`:/chal" -t xxx@sha256:xxx
  > 以container形式运行镜像。一般在题目的docker file中能看到`xxx@sha256:xxx`字样，这就是镜像（image）。-v指定双向挂载，任何在container内部的chal文件夹的文件也会出现在当前目录中（\`pwd\`命令）。
- 从Dockerfile build： https://stackoverflow.com/questions/36075525/how-do-i-run-a-docker-instance-from-a-dockerfile
    - 注意Dockerfile命名不要改成其他的，而且要放在当前目录下
    - `docker build --tag 'image_name' .`
    - `docker image ls`：查看build的image
- interactive运行docker image： https://stackoverflow.com/questions/40854482/interactive-command-in-dockerfile
    - `docker run -it <image id> /bin/bash`

## Qemu arm->amd64/x86->arm

- arm->amd64
    - https://rw1nd.github.io/2021/04/13/x86-on-arm/
    - https://levelup.gitconnected.com/running-amd64-linux-on-apple-m1-with-qemu-utm-64d67cccd6f8
- x86->arm
    - https://azeria-labs.com/arm-on-x86-qemu-user/

## gdb调试脚本

```python
from pwn import *
context.log_level='debug'
context.terminal = ["tmux", "splitw", "-h"] #分屏后ctrl+b o组合键切屏
p=process("gdb")
sla=lambda d,payload:p.sendlineafter(d,payload)
ia=lambda:p.interactive()
ra=lambda timeout=0.5:p.recvall(timeout=timeout)
rl=lambda keep=False:p.recvline(keepends=keep)
sl=lambda payload:p.sendline(payload)
rls=lambda line:p.recvlines(line)
ru=lambda payload,drop=True:p.recvuntil(payload,drop)
cl=lambda:p.close()
s=lambda payload:p.send(payload)
base=0x555555554000 
def PIEDebug(file,breakpoints,params=[]):
    sla("pwndbg>",f"file {file}")
    sla("pwndbg>",f"starti {' '.join(params)}")
    for i in breakpoints:
        sla("pwndbg>",f"b *{base+i}")
    sla("pwndbg>","c")
def test_format_string(times,start=0,end=''):
    payload=''
    for i in range(start,start+times):
        payload+=f'{i}:%{i}$p'+end
    return payload[:-1]
def get_register(reg):
    sla("pwndbg>","i r")
    contents=ru("gs").split(b'\n')[:-1]
    for i in contents:
        print(i)
        temp=i.split()
        register=temp[0]
        value=temp[1]
        if reg.encode() in register:
            return value
    return "none"
def set_register(register,value):
    sla("pwndbg>",f"set ${register} = {value}")
```

## 基础波形图绘制脚本

[参考](https://zhuanlan.zhihu.com/p/371394137)

```python
import numpy as np
import matplotlib.pyplot as plt
with open("res.txt") as f:
    d=f.read().split('\n')
traces=eval(d[1].split(':')[1])
t=np.arange(0, len(traces))
plt.plot(t, traces)
plt.show()
```

## linux命令替代

- [ls](https://ubunlog.com/en/alternativas-al-comando-ls/)
- [cat](https://unix.stackexchange.com/questions/86321/how-can-i-display-the-contents-of-a-text-file-on-the-command-line)
- [Specialer](https://blog.maple3142.net/2023/03/29/picoctf-2023-writeups/#specialer):`for f in **/*; do echo $(<$f); done`

## Core war

- [Core War](https://corewar.co.uk/index.htm)
- [koth](http://www.koth.org/info.html)

以下warrior都是standard redcode。

一个稳输的自毁warrior：

```
;redcode
;assert 1
ADD #-1, 3
MOV 2, @2
JMP -2
DAT #0, #0
```

一个稍微能赢一点的基础warrior(dwarf)：

```
;redcode
;assert 1
start   add.ab  #4, bmb
        mov.i   bmb, @bmb
        jmp     start
bmb     dat     #0, #0
```

一个胜率较高的warrior：

```
;redcode
;assert 1
        org    start

gate    dat    4000,       1700
bomb    dat    >2667,      11

        for    4
        dat    0,0
        rof

        spl    #4000,      >gate
clear   mov    bomb,       >gate
        djn.f  clear,      >gate

        for    23
        dat    0,0
        rof

        istep  equ 1143           ; (CORESIZE+1)/7

start   spl    clear-1
        mov    imp,        *launch
        spl    1                  ; 32 parallel processes
        spl    1
        spl    1
        spl    1
        spl    1
        spl    nxpoint
launch  djn.f  3600,       <4000

        for    2
        dat    0,0
        rof

nxpoint add.f  #istep,     launch
        djn.f  clear-1,    <3000

imp     mov.i  #1,         istep
```

## 打印嵌套文件夹内的所有文件内容

`find /path/to/folder -type f -exec cat {} \;`

## python画二维码

```python
from PIL import Image
MAX = 100
pic = Image.new("RGB",(MAX, MAX))
file = open("qr.txt",'r')
m = file.read().split('\n')
i=0
for y in range (0,MAX):
	for x in range (0,MAX):
		if(m[i] == '0'):
			pic.putpixel([x,y],(0, 0, 0))
		else:
			pic.putpixel([x,y],(255,255,255))
		i = i+1
pic.save("res.png")
```

```python
import numpy as np
from matplotlib import pyplot as plt

data = np.zeros((100, 100))

with open("qr.txt", "r") as f:
    idx = 0

    for bit in f:
        bit = int(bit)
        data[idx // 100][idx % 100] = bit

        idx = idx + 1

plt.imshow(data, interpolation = "nearest")
plt.show()
```

## python cv2描绘运动轨迹

利用前后帧生成光流，如果该光流往左下走则描绘出来

```python
import cv2,numpy as np,matplotlib.pyplot as plt
cap = cv2.VideoCapture('out_flag.mp4')
ret, frame = cap.read()
gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
mask = np.zeros_like(gray).astype(np.float64)
fr = 0
plt.figure(figsize=(12,8))
while True:
    fr +=1
    ret, frame = cap.read()
    if not ret:
        break
    gray_next = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    flow = cv2.calcOpticalFlowFarneback(gray, gray_next, None, 0.5, 3, 15, 3, 5, 1.2, 0)
    h, w = gray.shape
    y, x = np.mgrid[0:h:10, 0:w:10].reshape(2, -1).astype(int)
    fx, fy = flow[y, x].T
    lines = np.vstack([x, y, x + fx, y + fy]).T.reshape(-1, 2, 2)
    lines = np.int32(lines + 0.5)
    vis = np.zeros_like(gray)
    for (x1, y1), (x2, y2) in lines:
        if x1 > x2  and y1<y2:
            cv2.line(vis, (x1, y1), (x2, y2), 255 , 2)
    mask += vis&gray
    if fr % 10 ==0:
        show=mask.copy()
        cv2.putText(show,f'{fr}',(5,50), cv2.FONT_HERSHEY_SIMPLEX, 0.75, 255, 2)
        cv2.imshow('frame2', show)
        if cv2.waitKey(25) & 0xFF == ord('q'):
            break
    gray=gray_next
plt.imshow(np.log(mask))
plt.imshow(np.log(mask+1))
plt.show()
cap.release()
cv2.destroyAllWindows()
```

## [Visual cryptography](https://en.wikipedia.org/wiki/Visual_cryptography) python脚本

大概就是把两张黑白图片叠在一起，就能看见要传递的内容。

```python
import numpy as np
from PIL import Image
im1 = Image.open("1.png")
im2 = Image.open("2.png")
iminp = np.array(im1)
im2np = np.array(im2)
result = im2np + im1inp
Image.fromarray(result).save('result.png')
```

或者把信息用白色显现出来：

```python
from PIL import Image
# Load the first share
sharel = Image.open("img1.png") .convert('1')
# Load the second share
share2 = Image.open("img2.png") .convert('1')
# Get the size of the shares
width, height = sharel.size
# Create a new image for the result
result = Image.new("1", (width, height))
# Loop through each pixel in the shares and combine them
for x in range (width) :
    for y in range (height):
        pixell = sharel.getpixel((x, y))
        pixel2 = share2.getpixel((x, y))
        # If both pixels are black, set the result pixel to black
        if pixell == 0 and pixel2 == 0:
            result.putpixel((x, y), 0)
        # Otherwise, set the result pixel to white
        else:
            result.putpixel((x, y), 255)
# Save the resulting image
result.save("result.png")
```

## [perlin noise](https://en.wikipedia.org/wiki/Perlin_noise)图片生成+对比脚本

使用python模块[noise](https://github.com/caseman/noise)用perlin noise生成一张图片后对比另一张由perlin noise生成的图片，并把像素不同的地方标为黑色后写为结果图片。改一下也能用作两张普通图片的对比脚本。

```python
import noise
from PIL import Image
import numpy as np
# Set the seed for the Perlin noise generator
seed = 2151
# Set the size of the image
width = 1920
height = 1080
# Set the scale of the Perlin noise
scale = 100.0
# Create an empty NumPy array for the image
img_array = np.zeros((height, width))
# Loop through each pixel in the image and generate Perlin noise
for y in range(height):
    for x in range(width):
        img_array[y, x] = noise.pnoise2(x/scale, y/scale, octaves=6, persistence=0.5, lacunarity=2.0,repeatx=1024, repeaty=1024, base=seed)
# Create a PIL image from the NumPy array
img = Image.fromarray(np.uint8(img_array * 255))
img.save("res.png")
# Load the modified image
mod_img = Image.open('compare.png’')
# Create a new black image for the changed pixels
new_img = Image.new('RGB', (width, height), color='black')
# Get the pixel access objects for the images
orig_pixels = img.load()
mod_pixels = mod_img.load()
new_pixels = new_img.load()
# Loop through the pixels and identify changed pixels
for x in range(width):
    for y in range(height):
        orig_pixel = orig_pixels[x, y]
        mod_pixel = mod_ pixels[x, y]
        if orig_pixel != mod_pixel:
            # Change the pixel in the new image to white
            new_pixels[x, y] = (255, 255, 255)
# Save the new image with the changed pixels in white
new_img.save('changed_pixels_flag.png')
```

## [hashcat使用](https://xz.aliyun.com/t/4008)

下载：在[官网](https://hashcat.net/hashcat/)下载hashcat binaries，然后用`7z x`解压文件即可(7zip下载：`sudo apt-get install p7zip-full`)。linux运行`hashcat.bin`,windows运行`hashcat.exe`。

运行时指定hash模式的-m选项可以在[这里](https://hashcat.net/wiki/doku.php?id=example_hashes)找到。例如爆破zip，先用[zip2john](https://hashes.com/en/johntheripper/zip2john)将zip转为hash，然后根据hash格式选择-m的参数。-a是爆破模式。
- 掩码爆破：`./hashcat.bin -a 3 -m 13600 'hash' mask`
- 字典爆破：`./hashcat.bin -a 0 -m 13600 'hash' dict`

字典爆破linux /etc/shadow的hash： https://null-byte.wonderhowto.com/how-to/crack-shadow-hashes-after-getting-root-linux-system-0186386/
- `hashcat -m 500 -a 0 -o cracked.txt hashes.txt ./rockyou.txt -O`

## Extracting GPS Coordinates from metadata
https://github.com/BYU-CSA/BYUCTF-2023/tree/main/lost

## 利用[numba](http://zhaoxuhui.top/blog/2019/01/17/PythonNumba.html)和multiprocessing库加速爆破

感觉任何任务量较大的爆破题都可以像这题的脚本一样，一个线程爆破一个部分，同时numba提高代码执行效率。

[aluminum-isopropoxide](https://github.com/TJCSec/tjctf-2023-challenges/tree/main/crypto/aluminum-isopropoxide)
```py
from numba import jit
from multiprocessing import Pool

@jit(nopython=True)
def main(idx):
    f = b'l\x90C\x99e\x19\x03Br\x02\xd2\x98@\xf8\xe8deWOvv\x16[G}GA\\\xd2rv`\x16\x18'

    for key_ in range(idx, idx + 2**31//15):
        S_box = ...
        key_ = str(key_)
        S = []
        for i in range(255):
            S[i] = i
        j = 0
        for i in range(255):
            j = (j ^ S[i] ^ ord(key_[i % len(key_)])) % 256
            S[i], S[j] = S[j], S[i]

        amount = len(f)
        enc = f

        i = j = 0
        ctr = 0
        out = []
        while ctr < amount:
            i = (i * j) % 256
            j = (i + S[j]) % 256
            K = (S[i] & S[j])
            out.append(enc[ctr] ^ S_box[K])
            ctr += 1

        dec = "".join([chr(i) for i in out if chr(i) in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234566789}_{"])

        if len(dec) == len(f):
            print(dec)

if __name__ == '__main__':
    idx = [0,2**31//15,2**31//15 * 2,2**31//15 * 3,2**31//15 * 4,2**31//15 * 5,2**31//15 * 6,2**31//15 * 7,2**31//15 * 8,2**31//15 * 9,2**31//15 * 10,2**31//15 * 11,2**31//15 * 12,2**31//15 * 13,2**31//15 * 14]
    pool = Pool(15)
    with pool:
        for i in pool.imap_unordered(main, idx):
            print(i)
```

## python保存gif图片的每一帧
```py
from PIL import Image, ImageSequence
def save_frames(image_path):
    with Image.open(image_path) as im:
        for i, frame in enumerate(ImageSequence.Iterator(im)):
            frame.save(f'frames/frame_{i}.png', 'PNG')
```
## python tarfile使用

tar.extractall支持symbolic link，只检查文件的名称是不够的，服务端不做过滤就解压可能出现LFI
```py
import tarfile
with tarfile.open('exploit.tar.gz', 'w:gz') as tar:
    # First file
    info1 = tarfile.TarInfo("test")
    info1.type = tarfile.SYMTYPE
    info1.linkname = "/" 
    tar.addfile(info1)
    # Second file
    info2 = tarfile.TarInfo("./test/name") #若服务端指定不能以绝对路径/开头，可以这样绕过
    info2.type = tarfile.SYMTYPE
    info2.linkname = "linkname"
    tar.addfile(info2)
"""
The TarInfo class in the tarfile module is used to represent information about a file or directory in a tar archive. It provides attributes and methods to set and retrieve various properties of the file or directory.

Here are some key attributes of the TarInfo class:

name: The name of the file or directory. This can be an absolute or relative path.
size: The size of the file in bytes. For directories, this is set to 0.
mtime: The modification time of the file or directory, represented as a Unix timestamp.
type: The type of the file or directory. This can be one of the following constants defined in the tarfile module: tarfile.REGTYPE (regular file), tarfile.DIRTYPE (directory), tarfile.LNKTYPE (hard link), tarfile.SYMTYPE (symbolic link), tarfile.CHRTYPE (character special file), tarfile.BLKTYPE (block special file), tarfile.FIFOTYPE (FIFO special file), or tarfile.CONTTYPE (contiguous file).
linkname: The target of a hard link or symbolic link.
uid: The user ID of the owner of the file or directory.
gid: The group ID of the owner of the file or directory.
mode: The permissions of the file or directory, represented as an octal number.
"""
```

## 描绘纯色背景GIF中的单一物品的轨迹

- https://github.com/D13David/ctf-writeups/tree/main/tenablectf23/stego/ancient_scrawls
- https://github.com/ITSEC-ASIA-ID/Competitions/tree/main/CTF/2023/TenableCTF/Steganography/Ancient%20Scrawls

## Mac M1安装Ghidra

1. 去 https://github.com/NationalSecurityAgency/ghidra 下载最新版本ghidra
2. 去 https://www.oracle.com/java/technologies/downloads/ 下载要安装的ghidra版本的最低需求jdk
3. 运行ghidraRun。若要求输入jdk路径，输入jdk安装路径/Contents/Home

## C语言signal号表

https://www-uxsup.csx.cam.ac.uk/courses/moved.Building/signals.pdf

## JS下载文件

```js
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
async function download(){
    for(var i=0;i<100;i++){
        fetch('url')
        .then(response => response.blob())
        .then(blob => {
            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(blob);
            downloadLink.download = 'filename';
            downloadLink.click();
        });
        await sleep(500);
    }
}
```

## python获取wav文件频率

```py
import numpy as np
import scipy.io.wavfile as wav
ans=[]
for i in range(100):
    sample_rate, audio_data = wav.read('path')
    fft_data = np.fft.fft(audio_data)
    frequencies = np.fft.fftfreq(len(fft_data), 1/sample_rate)
    positive_frequencies = frequencies[:len(frequencies)//2]
    magnitude_spectrum = np.abs(fft_data[:len(fft_data)//2])
    max_index = np.argmax(magnitude_spectrum)
    max_frequency = positive_frequencies[max_index]
    ans.append(str(max_frequency)[:-2])
print(ans)
```

## 使用Filebin api

这样就能在linux终端上传文件了。去 https://filebin.net/api ，点击upload a file to a bin,点击Try it out，填写bin名（这个访问 https://filebin.net/ 就能得到一个名字）和上传的文件名。然后选择文件（随便一个即可），点击execute。如果成功，就可以copy curl命令到终端上。大概是这样：
```sh
curl -X 'POST' \
  'https://filebin.net/binname/filename' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/octet-stream' \
  --data-binary '@path/to/file'
```
上传成功后get`https://filebin.net/binname/filename`即可。今天用的时候发现服务器满了传不了文件，我又找了另一个api通用的filebin： https://arquivos-saude.recife.pe.gov.br/

## SMC文件解码

适用于简单的smc
```py
with open("SMC",'rb') as f:
    file=f.read()
offset= #smc code出现的偏移
length= #smc code段的长度
obfuscated=file[offset:offset+length]
res=[]
for i in obfuscated: #这块为具体的解码逻辑，可以比这里更复杂
    res.append(i^0x66)
res=bytes(res)
with open("/SMC_out",'wb') as f:
    f.write(file[:offset]+res+file[offset+length:]) #重新拼接回去
```
## python获取wav文件的频率

- [SimonProgrammer 3](https://github.com/4n86rakam1/writeup/tree/main/SunshineCTF_2023/scripting/SimonProgrammer_3)
- https://gist.github.com/c0nrad/66a322ca0e1b0ffc4261e2a9ed6b1f93
- https://github.com/Amagnum/Music-notes-detection/blob/master/music_notes_detection.py

## python恢复shifted image

shifted image看起来倾斜，像是被拉伸了一样

https://berliangabriel.github.io/post/tcp1p-ctf-2023/

## 其他类型

- 小端下将bytes转为数字：`int.from_bytes(msg, 'little')`。类似地，大端填`'big'`。