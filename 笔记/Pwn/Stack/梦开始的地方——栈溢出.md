# 梦开始的地方——栈溢出

以下内容来自[CTF Wiki](https://ctf-wiki.org/en/pwn/linux/user-mode/stackoverflow/x86/stackoverflow-basic/)，加上一点自己的理解。

栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。我们也不难发现，发生栈溢出的基本前提是：

- 程序必须向栈上写入数据。
- 写入的数据大小没有被良好地控制。

先不要管堆溢出和bss段溢出，这个要在后面进阶时才会遇到。栈溢出很好理解，从前面栈的知识可以知道，一个函数栈帧的大小是提前计划好的，正常情况下不会有问题。但安全有一条宗旨——不要相信用户。比如程序计划好0x16这么多的位置装用户输入，然后提示用户“请输入内容，不要超过0x16的大小“，你觉得用户会听程序的吗？如果就是叛逆，输入了很长的内容，会发生什么呢？

栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，当然需要确保这个地址所在的段具有可执行权限。

栈是一个很严谨的数据结构，说好了准备这么大你填的数据就不能超过这么大。超过了程序就罢工。罢工多没意思啊，让我们看看能不能通过研究栈的结构，找到可以利用的地方呢？当然可以。来看看下面这个程序。

```c
int vulnerable()
{
  char s; // [sp+4h] [bp-14h]@1

  gets(&s);
  return puts(&s);
}
```

也不能说是程序吧，经过反编译得来的。不过看起来比原程序简单，对非C玩家来说更有游戏体验。变量在栈上的布局如下。

             +-----------------+
             |     retaddr     |
             +-----------------+
             |     saved ebp   |
      ebp--->+-----------------+
             |                 |
             |                 |
             |                 |
             |                 |
             |                 |
             |                 |
s,ebp-0x14-->+-----------------+

来了，小学数学题。已知我们的武器是任意长的字符串，请问这把武器该怎么使用才可以控制当前函数的返回地址？提示ebp长4个字节。列式0x14+4=24,那么我们需要24个字符长的字符串就可以到达retaddr。最后得武器结构为24个任意字符+想要返回的地址。解毕。

所以地址怎么打？你可以在反编译器里找到目标地址，但是怎么打上去？直接输入就不用试了，行不通的。首先要知道，在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储。比如你想跳跃到0x0804843B，在内存中的形式就是\x3b\x84\x04\x08。后面的内容也就是你要输入的内容。

再等一下，你觉得\x3b算几个字符？如果你有接触过，你会说1个。但是计算机可不这么认为。你拿键盘输的，所以我把\算一个，x算一个，这有毛病吗？完全没有。这个时候就要借助工具了——pwntools。github能找到，快去看看吧，从现在起pwntools将是你征程中的挚友。

现在你知道了如何进攻，那么哪里会是可能的进攻点呢？通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下：

- 输入
  > gets，直接读取一行，忽略'\x00'
  > scanf
  > vscanf

- 输出
  > sprintf

- 字符串
  > strcpy，字符串复制，遇到'\x00'停止
  > strcat，字符串拼接，遇到'\x00'停止
  > bcopy

\x00可以理解成字符串的标准结尾。跟实际可能有点出入，不过暂时这么理解没啥事（应该吧？）。总结一下栈溢出武器的使用。

1.寻找进攻点
2.确定填充长度，也就是武器结构的前半部分。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式

- 相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得
- 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。
- 直接地址索引，就相当于直接给定了地址。

ghidra玩家怎么办？下面这张图可以告诉你。

![ghidra](../../攻防世界/images/_main_.png)

左侧粉色字体就是相对栈基地址的偏移了。

3.确定攻击目标。一般来说，我们会有如下的覆盖需求：

- 覆盖函数返回地址，这时候就是直接看 EBP 即可。
- 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。
- 覆盖 bss 段某个变量的内容。
- 根据现实执行情况，覆盖特定的变量或地址的内容。

覆盖地址可以直接或者间接地控制程序执行流程。

栈溢出很好玩，但是还不够。这么看就只能控制个返回地址来操控执行流程，就1步。1级的技能能打什么怪？所以我们需要将这个技能升级，可以一下进行多个步骤。升级了就可以给技能取个好听的名字了——ROP。