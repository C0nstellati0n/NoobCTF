# ROP - 1

以下内容来自[CTF Wiki](https://ctf-wiki.org/en/pwn/linux/user-mode/stackoverflow/x86/basic-rop/)，加上一点自己的理解。

随着冒险的推进，你会发现连小怪都有防御了。

- canary:在当前栈帧局部变量和返回地址中间加了一个随机值，叫canary。返回前会检查这个值，如果值与开始时不符就不会返回，直接终止程序。
- PIE（Position Independent Executable）：打乱加载基址，但是有点劣质，还要搭配另外一个防具。
- ASLR：Linux 平台下的地址空间分布随机化机制。即使可执行文件开启了 PIE 保护，还需要系统开启 ASLR 才会真正打乱基址，否则程序运行时依旧会在加载一个固定的基址上（不过和 No PIE 时基址不同）。
- NX：堆栈不可执行。直接向栈或者堆上直接注入代码的方式就失效了。

打破canary防御需要猜或者特殊情况下直接获得canary的值；PIE+ASLR需要拿到当前运行时的基址；NX就要靠今天学习的ROP来绕过了。其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。

之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件：

- 程序存在溢出，并且可以控制返回地址。
- 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。

如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。说了这么多，直接开始练习，光看哪里能知道讲的是啥。

## ret2text

ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。

这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。

如果你要调用的函数没有参数，那这个分类就跟简单栈溢出一样了。找到溢出点，放点垃圾字符，最后在返回地址填上自己的目标，完成，就这么简单。

## ret2shellcode

ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。

在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。

题目在ctf wiki可以看。其实这种也很简单，只是这次帮助溢出到返回地址的的字符不能乱填了，要用shellcode。shellcode可以直接用pwntools的asm(shellcraft.sh())获得。shellcode填写完后的剩余字符才用任意字符补齐，最后返回地址填这串shellcode的存储地址。要注意shellcode的存储地址所对应的区域需要可执行。

## ret2syscall
  
ret2syscall，即控制程序执行系统调用，获取 shell。

ret2shellcode的强制要求为shellcode 所在的区域具有可执行权限。可是很多时候并没有这么好的事。ret2text要求程序内部有专门的后门函数给你一步到位，就更不可能了。谁写程序时还会好心帮你写一个后门函数？由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用[系统调用](https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8)。

简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell

- execve("/bin/sh",NULL,NULL)

假设我们是32位程序，所以我们需要控制：

- 系统调用号，即 eax 应该为 0xb（execve的系统调用号是0xb）
- 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。
- 第二个参数，即 ecx 应该为 0
- 第三个参数，即 edx 应该为 0

而我们如何控制这些寄存器的值呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。寻找gadgets可以使用可以使用 ropgadgets这个工具。

rop就很像究极缝合怪行为。取几句话的一半然后拼在一起的效果可以和原话截然不同。比如一句话是“今天学习rop”，另一句话是“crypto为什么这么难”，缝合起来就是“rop为什么这么难”，完全不是原话想要表达的意思。程序也同理，本来好好的传参，调用函数，被我们各取一半然后拼在一起，shell就是我们的了。

看ctf wiki的例题的时候记得是一段gadget对应一段参数，比如pop_eax后跟上要传到eax里的值，然后再下一段gadget和参数。不是先一堆gadget再一堆参数。

## ret2libc

ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system("/bin/sh")，故而此时我们需要知道 system 函数的地址。

为什么一般是system呢？前面提到的execve需要三个参数，而system只需要一个。那肯定是谁简单选谁了。有的时候system会因为各种奇怪的原因用不了，这时再考虑execve。

注意这个rop链和系统调用的区别。

- 'a' * 112, system_plt, 'b' * 4, binsh_addr

发现了什么？在112个无用字符后直接调用system_plt（也就是调用system，plt和got的知识可以简单了解一下，目前不用了解太透彻），接着4个字符表示执行完system后的返回地址。由于我们只需要拿到shell，也就是执行system这个过程，所以之后返回到哪里就不重要了，随便填（是的就是利用完就扔:D）。然后才是调用system时的参数。注意和系统调用区分，此处无需将eax的值设为系统调用号，以及将参数传入通用寄存器。直接压到栈上就行了，因为32位就是靠栈来传参的。

这种情况也是理想化的。万一libc里没有/bin/sh这个字符串呢？我们可以自己造。在程序里找到一处可以写入的地方，比如熟悉的bss段。然后在执行system前先执行诸如gets这类获取输入的函数，手动创造/bin/sh。最后就和上面一样了，调用system，参数的位置填之前存储的位置。

- 'a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2

怎么理解这个payload呢？112不用说，gets_plt调用gets，pop_ebx将buf2弹入ebx，这是gets需要的参数。后面调用步骤也不用说了。

最后一个挑战。前面都是基于可以知道准确地址的情况，如果开启了ASLR呢？要利用两个知识点。

- system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。
- 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。

最低的那12位可以称之为偏移。所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而就可以推算出 system 函数的地址。常用的泄露函数是puts，因为只要一个参数。write备选项，三个参数还是有点烦的。

ctf wiki推荐libcsearcher，pwntools也有Dynelf。但我还是喜欢手动自己查，因为懒得再学别的了，加上本地机器没法运行elf。此外，libc 中是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址，就不用自己写了。（快去看例题！）

初级rop完毕，现在你应该对rop有一定认识了。目前都是32位，是时候看看64位的世界了。