# 堆的学习

我栈还没有学明白，就被题目一脚踢到堆里面。攻防世界6级以后几乎全是堆，比赛也遇见堆了，不学也得学。

当然要去[CTF Wiki](https://ctf-wiki.org/en/pwn/linux/user-mode/heap/ptmalloc2/heap-overview/)学了。所以这篇就是对wiki内容的笔记。

### 什么是堆

在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。

栈记得是从高地址向低地址增长的。合理，栈大小固定，高向低没什么问题；堆大小未知，不可能提前知道上限然后往下分配地址。

堆管理器处于用户程序与内核中间，主要做以下工作

1.响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。

2.管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。

堆管理器扮演着中介者的角色，比如房产中介。中介预先向操作系统申请很多连续的“房产”，用户想买直接找中介，无需麻烦系统，大家都省时省力。退还的房子还是放在中介那里，留给将来使用，可持续性发展。不知道这个比喻恰不恰当，目前来看还是很符合的。

需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。

房产中介手里握着一大批房产资源，但是用户摸不着，只有等你买了才有实实切切的房产证。房产证对应一个房子，很像堆的物理与虚拟的映射关系。

### 堆的基本操作

malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理

·当 n=0 时，返回当前系统允许的堆的最小内存块。

·当 n 为负数时，由于在大多数系统上，size_t 是无符号数（这一点非常重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。

free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。

此外，该函数也同样对异常情况进行了处理

·当 p 为空指针时，函数不执行任何操作。

·当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。

·除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。

#### 内存分配背后的系统调用

在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 (s)brk 函数以及 mmap, munmap 函数。

如下图所示，我们主要考虑对堆进行申请内存块的操作。

![brk&mmp](../images/brk&mmap.png)

(s)brk

对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。

初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同

·不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。

·开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。

这应该算是开启了ASLR后函数间相对地址还是一致的证明之一吧？ASLR只是把brk指的位置随机放在bss段结尾的位置后，一个物品无论放在哪里都不会改变其结构。

别忘了brk和sbrk都是函数，看上面的描述“指向”老是让我觉得是什么别的东西。sbrk(0)返回当前程序的中断位置，brk(addr)增加/减少程序的中断位置。

没有把所有的都抄下来，因为我突然发现我只需要抄要写笔记的部分就好了，不容易混淆和简单的直接去看wiki。

# [堆相关数据结构](https://ctf-wiki.org/en/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/)

开头慢慢看还行，直到我的脑子醒了过来，问我什么是[单向链表](https://www.jianshu.com/p/73f0d8f807aa)。看了一下发现概念不难，就是一个节点中不仅装着数据，还装着指向链表中下一个节点的地址。单向单向，拿到任意一个节点只能知道它下一个节点的位置，上一个节点就不知道了。

单向链表知道了那[双向链表](https://zh.wikipedia.org/wiki/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8)的概念也差不多了。双向就是除了装数据，还装着两个地址，一个往下个节点指，一个往上个节点指。这样就能实现任意顺序的遍历了。

提前把接下来会见到的[循环双向链表](https://juejin.cn/post/6844904117924691981#heading-8)一起记录了。假如我们得到了一个双向链表的尾节点，怎么找到头？可以是可以，就是要一层一层往上，有点累啊。循环双向链表就不一样了，双向链表的尾节点指向下一个节点的指针是null，循环双向指的是头节点；双向链表的头节点指向上一个节点的指针是null，循环双向指的是尾节点。完美闭环，大大提高了查找效率。

为了更加高效地利用 fast bin，glibc 采用单向链表对其中的每个 bin 进行组织，并且每个 bin 采取 LIFO 策略，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc 才会做接下来的一系列操作。

LIFO是Last In, First out，后进先出。FIFO则是First In,First out，先进先出。

后面的内容发现wiki已经讲得很清楚了，就没有要补充的笔记了。现在到了[malloc](https://github.com/JnuSimba/LinuxSecNotes/blob/master/Linux%20%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3glibc%20malloc.md)补充学习时间。这是学习unlink等漏洞的必经之路。

### 0x02 Arena
......

让我们来看一个运行在单核且操作系统为32位的计算机上的多线程应用（4线程=1个主线程+3个用户线程）的例子，这里线程的数量（4）>内核数量的2倍（2），因此在这种情况下，‘glibc malloc’认定multiple arenas 被所有可用线程共享，但是它是如何共享的呢？

·当主线程第一次调用malloc时，已经建立的main arena 会被无竞争的使用

·当线程1和线程2第一调用malloc时，一块新的arena会被建立 并被没有竞争的使用，此时线程和arena之间有着一对一的映射关系

·当线程3第一次调用malloc时，arena的限制数量会被 计算 出来，这里超过了arena的数量限制，所以就会尝试复用已经存在的arena（main arena，arena1或者arena2）

·复用:

1.一旦遍历出 可用arena，就开始自旋申请该arena的锁。

2.如果上锁成功（比如说main arena上锁成功），就将该arena 返回给用户。

3.如果查无可用arena，thread 3的malloc操作 阻塞，直到有可用的arena为止。

·当thread 3第二次调用malloc时，malloc会 尝试使用 上一次使用的arena（main arena）。当main arena可用时就用，否则thread 3就一直阻塞直至main arena被free掉。因此现在main arena实际上是被main thread和thread 3所共享。

这段提到的[自旋锁](https://www.cnblogs.com/cxuanBlog/p/11679883.html)是多线程资源锁的一种，简略概括就是当线程拿到一个资源后就会对其上锁，其他线程看到锁后就会等待，不断循环判断锁是否已经被释放。叫这个名字可能是因为循环判断就像在不停转圈，自己转圈就是“自旋”？